final databaseHelperProvider =
    Provider<DatabaseHelper>((ref) => DatabaseHelper());













                    //visualDensity: VisualDensity(vertical: -2),
                    // visualDensity: VisualDensity(horizontal: -1, vertical: -2),









import 'dart:math'; // Needed for random sample data
import 'package:flutter/material.dart'; // Needed for debugPrint
import 'package:sqflite/sqflite.dart';
import 'package:path/path.dart';
import 'package:path_provider/path_provider.dart';
import 'package:uuid/uuid.dart'; // Import the uuid package

// Helper function to check if a column exists (remains the same)
Future<bool> _columnExists(Database db, String table, String columnName) async {
  final columns = await db.rawQuery('PRAGMA table_info($table)');
  for (final col in columns) {
    if (col['name'] == columnName) {
      return true;
    }
  }
  return false;
}

class DatabaseHelper {
  // Singleton instance
  static final DatabaseHelper _instance = DatabaseHelper._internal();
  static Database? _database;
  final Uuid _uuid = const Uuid(); // Instantiate Uuid generator
  final Random _random = Random(); // Instantiate Random generator

  // Private constructor
  DatabaseHelper._internal();

  // Factory constructor to return the same instance
  factory DatabaseHelper() => _instance;

  // Getter to access the database
  Future<Database> get database async {
    if (_database != null) return _database!;
    _database = await _initDatabase();
    return _database!;
  }

  // --- Database Initialization and Schema ---
  // _initDatabase, _onCreate, table creation helpers, _insertDefaultSettings, _onUpgrade
  // ... (These methods remain the same as the previous version) ...
  Future<Database> _initDatabase() async {
    final directory = await getApplicationDocumentsDirectory();
    final path = join(directory.path, 'messages.db');
    return await openDatabase(
      path,
      version: 7, // Keep version consistent or increment if schema changes
      onOpen: (db) async {
        await db.execute("PRAGMA foreign_keys = ON");
      },
      onCreate: _onCreate,
      onUpgrade: _onUpgrade,
    );
  }

  Future<void> _onCreate(Database db, int version) async {
    await db.execute("PRAGMA foreign_keys = ON");
    debugPrint("Running _onCreate for database version $version");
    await _createMatchesTable(db);
    await _createEventsTable(db);
    await _createRoundsTable(db);
    await _createMessagesTable(db);
    await _createTrainingDataTable(db);
    await _createSettingsTable(db);
    await _insertDefaultSettings(db);
    debugPrint("_onCreate complete.");
  }

  Future<void> _createMatchesTable(Database db) async {
    await db.execute(
      '''
      CREATE TABLE matches(
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        matchName TEXT,
        matchDate TEXT,
        rounds INTEGER,
        finishedAtRound INTEGER,
        totalTime TEXT,
        roundTime INTEGER, -- Duration of each round in seconds
        breakTime INTEGER  -- Duration of break between rounds in seconds
      )
      ''',
    );
    debugPrint("Table 'matches' created.");
  }

  Future<void> _createEventsTable(Database db) async {
    await db.execute(
      '''
      CREATE TABLE events(
        id TEXT PRIMARY KEY,
        timestamp INTEGER,
        matchId INTEGER,
        winner TEXT,
        FOREIGN KEY (matchId) REFERENCES matches(id) ON DELETE CASCADE
      )
      ''',
    );
    debugPrint("Table 'events' created.");
  }

  Future<void> _createRoundsTable(Database db) async {
    await db.execute(
      '''
      CREATE TABLE rounds(
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        eventId TEXT,
        punchCount INTEGER, -- This seems redundant if calculated from messages
        matchId INTEGER,
        round INTEGER,
        timestamp INTEGER,
        FOREIGN KEY (matchId) REFERENCES matches(id) ON DELETE CASCADE,
        FOREIGN KEY (eventId) REFERENCES events(id) ON DELETE CASCADE,
        UNIQUE(eventId, round)
      )
      ''',
    );
    debugPrint("Table 'rounds' created.");
  }

  Future<void> _createMessagesTable(Database db) async {
    await db.execute(
      '''
      CREATE TABLE messages(
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        device TEXT,         -- Who is wearing the sensor ('BlueBoxer', 'RedBoxer')
        punchBy TEXT,        -- Who threw the punch ('BlueBoxer', 'RedBoxer')
        punchCount TEXT,     -- The sequential count of this punch *by this boxer* in this round
        timestamp TEXT,      -- Time within the round (e.g., "00:01:23")
        sensorValue TEXT,    -- Sensor reading
        roundId INTEGER,
        matchId INTEGER,
        FOREIGN KEY (roundId) REFERENCES rounds(id) ON DELETE CASCADE,
        FOREIGN KEY (matchId) REFERENCES matches(id) ON DELETE CASCADE
      )
      ''',
    );
    debugPrint("Table 'messages' created.");
  }

  Future<void> _createTrainingDataTable(Database db) async {
    await db.execute(
      '''
      CREATE TABLE trainingdata(
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        device TEXT,
        punchBy TEXT,
        punchCount TEXT,
        timestamp TEXT,
        sensorValue TEXT,
        roundId INTEGER -- Might not be applicable for general training?
      )
      ''',
    );
    debugPrint("Table 'trainingdata' created.");
  }

  Future<void> _createSettingsTable(Database db) async {
    await db.execute(
      '''
      CREATE TABLE settings(
        id INTEGER PRIMARY KEY,
        fsrSensitivity INTEGER,
        fsrThreshold INTEGER,
        roundTime INTEGER,
        breakTime INTEGER,
        secondsBeforeRoundBegins INTEGER,
        rounds INTEGER
      )
      ''',
    );
    debugPrint("Table 'settings' created.");
  }

  Future<void> _insertDefaultSettings(Database db) async {
    await db.insert('settings', {
      'id': 1,
      'fsrSensitivity': 800,
      'fsrThreshold': 200,
      'roundTime': 180, // 3 minutes default round time
      'breakTime': 60, // 1 minute default break time
      'secondsBeforeRoundBegins': 5,
      'rounds': 3, // Default number of rounds
    }, conflictAlgorithm: ConflictAlgorithm.replace);
    debugPrint("Default settings inserted/replaced.");
  }

  Future<void> _onUpgrade(Database db, int oldVersion, int newVersion) async {
    debugPrint("Upgrading database from version $oldVersion to $newVersion");
    // Add upgrade logic based on version differences
    // Example: Add 'device' column if upgrading from version < 4
    if (oldVersion < 4) {
      if (!await _columnExists(db, 'messages', 'device')) {
        await db.execute('ALTER TABLE messages ADD COLUMN device TEXT');
        debugPrint("Added 'device' column to messages table.");
      }
    }
    if (oldVersion < 5) {
      // Add columns added in version 5
       if (!await _columnExists(db, 'settings', 'fsrThreshold')) {
         await db.execute(
           'ALTER TABLE settings ADD COLUMN fsrThreshold INTEGER DEFAULT 200',
         );
         debugPrint("Added 'fsrThreshold' column to settings table.");
       }
       if (!await _columnExists(db, 'settings', 'roundTime')) {
         await db.execute(
           'ALTER TABLE settings ADD COLUMN roundTime INTEGER DEFAULT 180',
         );
         debugPrint("Added 'roundTime' column to settings table.");
       }
       if (!await _columnExists(db, 'settings', 'breakTime')) {
         await db.execute(
           'ALTER TABLE settings ADD COLUMN breakTime INTEGER DEFAULT 60',
         );
         debugPrint("Added 'breakTime' column to settings table.");
       }
       if (!await _columnExists(db, 'settings', 'secondsBeforeRoundBegins')) {
         await db.execute(
           'ALTER TABLE settings ADD COLUMN secondsBeforeRoundBegins INTEGER DEFAULT 5',
         );
         debugPrint(
           "Added 'secondsBeforeRoundBegins' column to settings table.",
         );
       }
    }
     if (oldVersion < 6) {
       if (!await _columnExists(db, 'messages', 'punchBy')) {
         await db.execute('ALTER TABLE messages ADD COLUMN punchBy TEXT');
         debugPrint("Added 'punchBy' column to messages table.");
       }
     }
     if (oldVersion < 7) {
       if (!await _columnExists(db, 'settings', 'rounds')) {
         await db.execute(
           'ALTER TABLE settings ADD COLUMN rounds INTEGER DEFAULT 3',
         );
         debugPrint("Added 'rounds' column to settings table.");
       }
     }
    // Add more upgrade steps as needed for future versions
    debugPrint("Database upgrade complete.");
  }


  // --- Sample Data Insertion ---

  /// Clears all data from relevant tables. Call before inserting sample data.
  Future<void> _clearAllData() async {
    final db = await database;
    debugPrint("Clearing existing data...");
    // Delete in reverse order of dependency due to foreign keys
    await db.delete('messages');
    await db.delete('trainingdata');
    await db.delete('rounds');
    await db.delete('events');
    await db.delete('matches');
    debugPrint("Data cleared.");
  }

  /// Formats total seconds into HH:MM:SS string.
  String _formatSecondsToTimeString(int totalSeconds) {
    if (totalSeconds < 0) totalSeconds = 0; // Ensure non-negative
    int s = totalSeconds % 60;
    int m = (totalSeconds ~/ 60) % 60;
    int h = totalSeconds ~/ 3600;
    return "${h.toString().padLeft(2, '0')}:${m.toString().padLeft(2, '0')}:${s.toString().padLeft(2, '0')}";
  }

  /// **NEW HELPER:** Generates and inserts realistic, interleaved punch messages for a given round.
  Future<int> _insertRandomizedMessagesForRound({
    required Database db,
    required int roundId,
    required int matchId,
    required int roundTimeSeconds, // Duration of the round
    required int avgPunchesPerBoxer, // Average punches for variability
  }) async {
    int messagesInserted = 0;
    int bluePunchCounter = 0;
    int redPunchCounter = 0;

    // Determine total punches for the round (with some randomness)
    int bluePunches = avgPunchesPerBoxer + _random.nextInt(avgPunchesPerBoxer ~/ 2 + 1) - (avgPunchesPerBoxer ~/ 4);
    int redPunches = avgPunchesPerBoxer + _random.nextInt(avgPunchesPerBoxer ~/ 2 + 1) - (avgPunchesPerBoxer ~/ 4);
    int totalPunches = bluePunches + redPunches;
    if (totalPunches <= 0) return 0; // No punches to insert

    List<Map<String, dynamic>> punchEvents = [];

    // Generate punch events with random times and assign boxer randomly based on target counts
    List<String> boxers = List.filled(bluePunches, 'BlueBoxer') + List.filled(redPunches, 'RedBoxer');
    boxers.shuffle(_random); // Randomize the order of punches

    for (String boxer in boxers) {
       // Generate a random time within the round duration
      int timestampSeconds = _random.nextInt(roundTimeSeconds); // 0 to roundTimeSeconds-1
      String device = boxer; // The one wearing the sensor
      String punchBy = boxer; // The one throwing the punch (simplified for this example)
      // String punchBy = (boxer == 'BlueBoxer' ? 'RedBoxer' : 'BlueBoxer'); // If sensor detects opponent's punch

      punchEvents.add({
        'device': device,
        'punchBy': punchBy,
        'timestampSeconds': timestampSeconds,
        'sensorValue': (_random.nextInt(600) + 200).toString(), // Random sensor value
      });
    }


    // Sort punches chronologically
    punchEvents.sort((a, b) => (a['timestampSeconds'] as int).compareTo(b['timestampSeconds'] as int));

    // Insert sorted punches with correct sequential counts per boxer
    for (var punchEvent in punchEvents) {
      String currentPunchCount;
      if (punchEvent['punchBy'] == 'BlueBoxer') {
        bluePunchCounter++;
        currentPunchCount = bluePunchCounter.toString();
      } else {
        redPunchCounter++;
        currentPunchCount = redPunchCounter.toString();
      }

      String timeString = _formatSecondsToTimeString(punchEvent['timestampSeconds']);

      await insertMessage(
        punchEvent['device'],
        punchEvent['punchBy'], // Assuming punchBy is the same as device for simplicity here
        currentPunchCount,
        timeString,
        punchEvent['sensorValue'],
        roundId,
        matchId,
      );
      messagesInserted++;
    }
    return messagesInserted;
  }


  /// Inserts a comprehensive set of sample data for testing.
  Future<void> insertComprehensiveSampleData() async {
    final db = await database;
    await _clearAllData();
    await _insertDefaultSettings(db); // Ensure settings are present

    debugPrint("Inserting comprehensive sample data...");

    // Store details of inserted matches to access roundTime later
    List<Map<String, dynamic>> insertedMatchesDetails = [];
    List<int> matchIds = [];

    try {
      // 1. Insert Sample Matches
      List<Map<String, dynamic>> sampleMatchesData = [
        // Match 0: 1 Round, 1 min round time
        {
          'matchName': 'Quick Spar (1 Round)',
          'matchDate': '2025-04-27',
          'rounds': 1,
          'finishedAtRound': 1, // Finished
          'totalTime': '01:00', // Approx
          'roundTime': 60, // 1 minute
          'breakTime': 10,
        },
        // Match 1: 3 Rounds, 1.5 min round time
        {
          'matchName': 'Standard Bout (3 Rounds)',
          'matchDate': '2025-04-27',
          'rounds': 3,
          'finishedAtRound': 3, // Finished
          'totalTime': '06:00', // Approx 3*1.5 + 2*0.5
          'roundTime': 90, // 1.5 minutes
          'breakTime': 30,
        },
        // Match 2: 2 Rounds, 30 sec round time (Very Short)
        {
          'matchName': 'Short Rounds (2 Rounds)',
          'matchDate': '2025-04-26',
          'rounds': 2,
          'finishedAtRound': 0, // Not finished yet
          'totalTime': '00:00',
          'roundTime': 30, // 30 seconds
          'breakTime': 10,
        },
         // Match 3: 5 Rounds, 3 min round time
        {
          'matchName': 'Endurance Test (5 Rounds)',
          'matchDate': '2025-04-25',
          'rounds': 5,
          'finishedAtRound': 5, // Finished
          'totalTime': '19:00', // Approx 5*3 + 4*1
          'roundTime': 180, // 3 minutes
          'breakTime': 60,
        },
        // Add more diverse matches if needed
         {
          'matchName': 'BlueBoxer vs RedBoxer',
          'matchDate': '2025-03-07',
          'rounds': 3,
          'finishedAtRound': 0,
          'totalTime': '00:00',
          'roundTime': 180, // 3 min
          'breakTime': 60,
        },
        {
          'matchName': 'Themis vs Nick',
          'matchDate': '2025-03-07',
          'rounds': 5,
          'finishedAtRound': 0,
          'totalTime': '00:00',
          'roundTime': 180, // 3 min
          'breakTime': 60,
        },
      ];

      for (var matchData in sampleMatchesData) {
        final id = await insertMatch(
          matchName: matchData['matchName'],
          rounds: matchData['rounds'],
          matchDate: matchData['matchDate'],
          roundTime: matchData['roundTime'],
          breakTime: matchData['breakTime'],
        );
        matchIds.add(id);
        // Store details including the ID and roundTime
        insertedMatchesDetails.add({...matchData, 'id': id});

        // Update finished matches immediately
        if (matchData['finishedAtRound'] > 0) {
          await updateEditMatch(
            id: id,
            matchName: matchData['matchName'],
            matchDate: matchData['matchDate'],
            rounds: matchData['rounds'],
            finishedAtRound: matchData['finishedAtRound'],
            totalTime: matchData['totalTime'],
            roundTime: matchData['roundTime'],
            breakTime: matchData['breakTime'],
          );
        }
      }
      debugPrint("Inserted ${matchIds.length} sample matches.");

      // 2. Insert Sample Events and Rounds (Simplified: One event per match for sample data)
      List<String> eventIds = [];
      List<Map<String, dynamic>> roundDetails = []; // Store {roundId, matchId, roundNumber, eventId}

      for (var matchDetail in insertedMatchesDetails) {
        int matchId = matchDetail['id'];
        int numRounds = matchDetail['rounds'];
        int finishedAt = matchDetail['finishedAtRound'];
        String? winner = (finishedAt > 0)
            ? (_random.nextBool() ? (_random.nextBool() ? 'BlueBoxer' : 'RedBoxer') : 'Draw')
            : null; // Assign winner randomly if finished

        String eventId = await insertEvent(matchId: matchId, winner: winner);
        eventIds.add(eventId);

        // Insert rounds up to the number specified in the match, or finishedAtRound if it's finished
        int roundsToInsert = (finishedAt > 0 && finishedAt <= numRounds) ? finishedAt : numRounds;
        // If not finished (finishedAt == 0), we might only insert *some* rounds if simulating an ongoing match
        // For simplicity here, if not finished, we'll insert rounds as if it's *about* to start or ongoing.
        // Let's insert rounds for matches that aren't marked as finished yet too.
        roundsToInsert = numRounds; // Insert all potential rounds for simplicity

        for (int r = 1; r <= roundsToInsert; r++) {
          int roundId = await insertRound(matchId: matchId, eventId: eventId, round: r);
          if (roundId > 0) {
            roundDetails.add({
              'roundId': roundId,
              'matchId': matchId,
              'roundNumber': r,
              'eventId': eventId
            });
          }
        }
      }
      debugPrint("Inserted ${eventIds.length} sample events.");
      debugPrint("Inserted ${roundDetails.length} sample rounds.");


      // 3. Insert Sample Messages using the new randomized helper
      int totalMessagesInserted = 0;
      for (var roundInfo in roundDetails) {
        int roundId = roundInfo['roundId'];
        int matchId = roundInfo['matchId'];

        // Find the corresponding match details to get roundTime
        final matchDetail = insertedMatchesDetails.firstWhere((m) => m['id'] == matchId);
        int roundTimeSeconds = matchDetail['roundTime'] as int;

        // Determine average punches based on round time (e.g., more punches for longer rounds)
        int avgPunches = (roundTimeSeconds / 60 * 15).round(); // Approx 15 punches per minute avg
        avgPunches = max(5, avgPunches); // Ensure at least a few punches even for short rounds

        debugPrint("Inserting messages for Match $matchId, Round ${roundInfo['roundNumber']} (ID: $roundId), Round Time: $roundTimeSeconds s, Avg Punches: $avgPunches");

        int messagesForThisRound = await _insertRandomizedMessagesForRound(
          db: db,
          roundId: roundId,
          matchId: matchId,
          roundTimeSeconds: roundTimeSeconds,
          avgPunchesPerBoxer: avgPunches ~/ 2, // Per boxer
        );
        totalMessagesInserted += messagesForThisRound;
         debugPrint(" -> Inserted $messagesForThisRound messages for Round $roundId.");
      }
      debugPrint("Inserted a total of $totalMessagesInserted sample messages across all rounds.");


      // 4. Insert Sample Training Data (Timestamp remains fully random HH:MM:SS)
      int trainingDataInserted = 0;
      for (int i = 0; i < 50; i++) {
        String device = _random.nextBool() ? 'BlueBoxer' : 'RedBoxer';
        String punchBy = device; // Simplification for training data
        // Keep timestamp fully random (00:00:00 to 23:59:59) for training data
        String timeString =
            "${_random.nextInt(24).toString().padLeft(2, '0')}:${_random.nextInt(60).toString().padLeft(2, '0')}:${_random.nextInt(60).toString().padLeft(2, '0')}";
        await insertTrainingData(
          device,
          punchBy,
          (i + 1).toString(), // Using loop index as dummy punch count
          timeString,
          (_random.nextInt(800) + 100).toString(), // Random sensor value
        );
        trainingDataInserted++;
      }
      debugPrint(
        "Inserted $trainingDataInserted sample training data records.",
      );

      debugPrint("Comprehensive sample data insertion COMPLETE.");

    } catch (e, stacktrace) {
      debugPrint("Error inserting sample data: $e");
      debugPrint("Stacktrace: $stacktrace");
      // Consider re-throwing or handling the error more robustly
    }
  }


  // --- METHOD SIGNATURES AND UTILITY METHODS --- (No changes needed below this line)

  // Messages
  Future<int> insertMessage( // Return int (the inserted row id) or void
    String device,
    String punchBy, // Changed from oppositeDevice for clarity
    String punchCount,
    String timestamp, // Should be HH:MM:SS format for round time
    String sensorValue,
    int roundId,
    int matchId,
  ) async {
    final db = await database;
    // Basic validation
    if (device.isEmpty || punchBy.isEmpty || roundId <= 0 || matchId <= 0) {
       debugPrint("Warning: Invalid data provided to insertMessage. Skipping insert.");
       return 0; // Indicate failure or skip
    }
    try {
       final id = await db.insert('messages', {
         'device': device,
         'punchBy': punchBy,
         'punchCount': punchCount,
         'timestamp': timestamp, // Store as text "HH:MM:SS"
         'sensorValue': sensorValue,
         'roundId': roundId,
         'matchId': matchId,
       });
       return id;
    } catch (e) {
       debugPrint("Error inserting message: $e");
       return 0; // Indicate failure
    }
  }

  Future<List<Map<String, dynamic>>> fetchMessages() async {
    final db = await database;
    return await db.query('messages', orderBy: 'id DESC');
  }

  Future<List<Map<String, dynamic>>> fetchMessagesByMatchId(int matchId) async {
    final db = await database;
    return await db.query(
      'messages',
      where: 'matchId = ?',
      whereArgs: [matchId],
      orderBy: 'id ASC', // Often useful to see messages in order
    );
  }

  Future<List<Map<String, dynamic>>> fetchMessagesByRoundId(int roundId) async {
    final db = await database;
    // For now, sort by ID which approximates chronological order if inserted correctly
    return await db.query(
      'messages',
      where: 'roundId = ?',
      whereArgs: [roundId],
      orderBy: 'id ASC', // Order by insertion sequence
    );
  }

   /// Fetches messages for a specific round, ordered chronologically by timestamp.
   /// Note: This requires parsing the 'timestamp' string, which can be inefficient.
   /// Consider storing timestamp as INTEGER seconds within the round if performance is critical.
   Future<List<Map<String, dynamic>>> fetchMessagesByRoundIdOrdered(int roundId) async {
     final db = await database;
     final messages = await db.query(
       'messages',
       where: 'roundId = ?',
       whereArgs: [roundId],
       // No DB-level order by HH:MM:SS string easily, so fetch all and sort in Dart
     );

     // Helper to parse HH:MM:SS to seconds
     int parseTimeStringToSeconds(String timeString) {
       try {
         final parts = timeString.split(':');
         if (parts.length == 3) {
           int h = int.parse(parts[0]);
           int m = int.parse(parts[1]);
           int s = int.parse(parts[2]);
           return h * 3600 + m * 60 + s;
         }
       } catch (e) {
         debugPrint("Error parsing time string '$timeString': $e");
       }
       return 0; // Default or error case
     }

     // Sort the results in Dart
     messages.sort((a, b) {
       final timeA = parseTimeStringToSeconds(a['timestamp'] as String? ?? '00:00:00');
       final timeB = parseTimeStringToSeconds(b['timestamp'] as String? ?? '00:00:00');
       return timeA.compareTo(timeB);
     });

     return messages;
   }


  Future<void> clearMessages() async {
    final db = await database;
    await db.delete('messages');
    debugPrint("Cleared messages table.");
  }

  // Training Data
  Future<void> insertTrainingData(
    String device,
    String punchBy,
    String punchCount,
    String timestamp, // HH:MM:SS format
    String sensorValue,
    // int? roundId, // Optional: Link training data to a round if applicable
  ) async {
    final db = await database;
    await db.insert('trainingdata', {
      'device': device,
      'punchBy': punchBy,
      'punchCount': punchCount,
      'timestamp': timestamp, // Store as text "HH:MM:SS"
      'sensorValue': sensorValue,
      // 'roundId': roundId,
    });
  }

  Future<List<Map<String, dynamic>>> fetchTrainingData() async {
    final db = await database;
    return await db.query('trainingdata', orderBy: 'id DESC');
  }

  Future<void> clearTrainingData() async {
    final db = await database;
    await db.delete('trainingdata');
    debugPrint("Cleared trainingdata table.");
  }

  // Settings
  Future<void> upsertSettings({
    required int fsrSensitivity,
    required int fsrThreshold,
    required int rounds,
    required int roundTime, // in seconds
    required int breakTime, // in seconds
    required int secondsBeforeRoundBegins,
  }) async {
    final db = await database;
    await db.insert('settings', {
      'id': 1, // Always use ID 1 for the single settings row
      'fsrSensitivity': fsrSensitivity,
      'fsrThreshold': fsrThreshold,
      'rounds': rounds,
      'roundTime': roundTime,
      'breakTime': breakTime,
      'secondsBeforeRoundBegins': secondsBeforeRoundBegins,
    }, conflictAlgorithm: ConflictAlgorithm.replace); // Replace existing settings
    debugPrint("Settings upserted.");
  }

  Future<Map<String, dynamic>?> fetchSettings() async {
    final db = await database;
    final List<Map<String, dynamic>> settings = await db.query(
      'settings',
      where: 'id = ?',
      whereArgs: [1], // Fetch the settings row with ID 1
      limit: 1,
    );
    if (settings.isNotEmpty) {
      return settings.first;
    } else {
      debugPrint("Warning: Settings not found, returning null. Consider inserting defaults.");
      // Optionally insert defaults here if they are missing
      // await _insertDefaultSettings(db);
      // final List<Map<String, dynamic>> defaultSettings = await db.query('settings', where: 'id = ?', whereArgs: [1], limit: 1);
      // return defaultSettings.isNotEmpty ? defaultSettings.first : null;
      return null;
    }
  }

  Future<void> clearSettings() async {
    final db = await database;
    // Instead of deleting, just reset to defaults
    await _insertDefaultSettings(db);
    debugPrint("Settings reset to default.");
  }

  // Matches
  Future<int> insertMatch({
    required String matchName,
    required int rounds,
    required String matchDate, // Consider storing as ISO8601 string or INTEGER timestamp
    required int roundTime, // in seconds
    required int breakTime, // in seconds
  }) async {
    final db = await database;
    final Map<String, dynamic> matchData = {
      'matchName': matchName,
      'rounds': rounds,
      'matchDate': matchDate, // Store as provided string
      'roundTime': roundTime,
      'breakTime': breakTime,
      'finishedAtRound': 0, // Default: Not finished
      'totalTime': '00:00:00', // Default: No time elapsed yet
    };
    final id = await db.insert('matches', matchData);
    debugPrint("Inserted match '$matchName' with ID: $id");
    return id;
  }

  Future<void> updateEditMatch({
    required int id,
    required String matchName,
    required String matchDate,
    required int rounds,
    required int finishedAtRound, // The round number it finished *after* (0 if not finished)
    required String totalTime, // Total duration HH:MM:SS
    required int roundTime,
    required int breakTime,
  }) async {
    final db = await database;
    int count = await db.update(
      'matches',
      {
        'matchName': matchName,
        'matchDate': matchDate,
        'rounds': rounds,
        'finishedAtRound': finishedAtRound,
        'totalTime': totalTime, // Store as HH:MM:SS string
        'roundTime': roundTime,
        'breakTime': breakTime,
      },
      where: 'id = ?',
      whereArgs: [id],
    );
     if (count > 0) {
        debugPrint("Updated match with ID: $id");
     } else {
        debugPrint("Warning: Match with ID $id not found for update.");
     }
  }

  Future<List<Map<String, dynamic>>> fetchMatches() async {
    final db = await database;
    // Order by date descending (most recent first), then by ID as fallback
    return await db.query('matches', orderBy: 'matchDate DESC, id DESC');
  }

  Future<void> deleteMatch(int id) async {
    final db = await database;
    // Foreign key constraints with ON DELETE CASCADE should handle related data
    int count = await db.delete('matches', where: 'id = ?', whereArgs: [id]);
    if (count > 0) {
      debugPrint("Deleted match with ID: $id and related data (via CASCADE).");
    } else {
      debugPrint("Match with ID: $id not found for deletion.");
    }
  }

  Future<Map<String, dynamic>?> fetchMatchById(int id) async {
    final db = await database;
    final result = await db.query(
      'matches',
      where: 'id = ?',
      whereArgs: [id],
      limit: 1,
    );
    return result.isNotEmpty ? result.first : null;
  }

  Future<void> clearMatches() async {
    final db = await database;
    // This will cascade delete related events, rounds, and messages
    await db.delete('matches');
    debugPrint("Cleared matches table and related data (via CASCADE).");
  }

  // Events
  Future<String> insertEvent({required int matchId, String? winner}) async {
    final db = await database;
    String eventId = _uuid.v4(); // Generate a unique ID for the event
    await db.insert('events', {
      'id': eventId,
      'timestamp': DateTime.now().millisecondsSinceEpoch, // Record event creation time
      'matchId': matchId,
      'winner': winner, // Can be null if match is ongoing or a draw
    });
    debugPrint("Inserted event $eventId for Match ID $matchId");
    return eventId;
  }

  Future<List<Map<String, dynamic>>> fetchEvents() async {
    final db = await database;
    return await db.query('events', orderBy: 'timestamp DESC'); // Most recent events first
  }

  Future<List<Map<String, dynamic>>> fetchEventsByMatchId(int matchId) async {
    final db = await database;
    return await db.query(
      'events',
      where: 'matchId = ?',
      whereArgs: [matchId],
      orderBy: 'timestamp DESC', // Usually only one event per match in current design
    );
  }

  Future<void> clearEvents() async {
    final db = await database;
    // This will cascade delete related rounds and messages
    await db.delete('events');
    debugPrint("Cleared events table and related data (via CASCADE).");
  }

  Future<void> updateCurrentEventWinner(String eventId, String? winner) async {
    final db = await database;
    int count = await db.update(
      'events',
      {'winner': winner}, // Update only the winner field
      where: 'id = ?',
      whereArgs: [eventId],
    );
     if (count > 0) {
       debugPrint("Updated winner for event $eventId to '$winner'");
     } else {
       debugPrint("Warning: Event with ID $eventId not found for winner update.");
     }
  }

  // Rounds
  Future<int> insertRound({
    required int matchId,
    required int round, // The round number (1, 2, 3...)
    required String? eventId, // Associated event
  }) async {
    final db = await database;
    final roundData = {
      'matchId': matchId,
      'round': round,
      'eventId': eventId,
      'timestamp': DateTime.now().millisecondsSinceEpoch, // Record round creation time
      // 'punchCount': 0, // Initial punch count - might be better calculated dynamically
    };
    int id = 0;
    try {
      // Use insert with conflictAlgorithm ignore or retrieve existing if needed
      id = await db.insert(
          'rounds',
          roundData,
          conflictAlgorithm: ConflictAlgorithm.ignore); // Ignore if UNIQUE constraint fails
      if (id > 0) {
         debugPrint("Inserted round $round for Event $eventId, Round ID: $id");
      } else {
         // If ID is 0, it means the round likely already existed due to UNIQUE constraint
         debugPrint("Round $round for Event $eventId likely already exists (or other insert error).");
         // Optionally, query to get the existing ID if needed
         final existing = await db.query('rounds', where: 'eventId = ? AND round = ?', whereArgs: [eventId, round], limit: 1);
         if (existing.isNotEmpty) {
           id = existing.first['id'] as int;
           debugPrint("Found existing Round ID: $id");
         }
      }
    } on DatabaseException catch (e) {
      // Catch specific errors if needed, though ConflictAlgorithm.ignore handles UNIQUE
      debugPrint("Database error inserting round: $e");
      // Rethrow or handle as appropriate
    }
    return id; // Return the new ID or the existing ID if found, or 0 on error
  }


  Future<List<Map<String, dynamic>>> fetchRounds() async {
    final db = await database;
    // Fetch rounds, potentially joining with events/matches if needed later
    List<Map<String, dynamic>> rounds = await db.query(
      'rounds',
      orderBy: 'matchId ASC, round ASC', // Order logically
    );
    // Add human-readable timestamp (consider doing this formatting in the UI layer)
    return rounds.map((round) {
      final timestamp = round['timestamp'];
      String humanReadableTimestamp = "N/A";
      if (timestamp != null && timestamp is int) {
        try {
          var date = DateTime.fromMillisecondsSinceEpoch(timestamp);
          humanReadableTimestamp =
              "${date.year}-${date.month.toString().padLeft(2, '0')}-${date.day.toString().padLeft(2, '0')} ${date.hour.toString().padLeft(2, '0')}:${date.minute.toString().padLeft(2, '0')}:${date.second.toString().padLeft(2, '0')}";
        } catch (e) {
          debugPrint("Error formatting timestamp $timestamp: $e");
        }
      }
      // Create a mutable copy to add the formatted timestamp
      var mutableRound = Map<String, dynamic>.from(round);
      mutableRound['humanReadableTimestamp'] = humanReadableTimestamp;
      return mutableRound;
    }).toList();
  }

   Future<List<Map<String, dynamic>>> fetchRoundsByEventId(String eventId) async {
     final db = await database;
     return await db.query(
       'rounds',
       where: 'eventId = ?',
       whereArgs: [eventId],
       orderBy: 'round ASC', // Order by round number
     );
   }

  Future<void> clearRounds() async {
    final db = await database;
    // This will cascade delete related messages
    await db.delete('rounds');
    debugPrint("Cleared rounds table and related data (via CASCADE).");
  }

  // Utilities

  /// Calculates punch counts for an entire event by summing counts from its rounds.
  Future<Map<String, int>> getEventPunchCounts(String eventId) async {
    final db = await database;
    // Find all round IDs associated with the event
    final eventRounds = await db.query(
      'rounds',
      columns: ['id'], // Only need the round IDs
      where: 'eventId = ?',
      whereArgs: [eventId],
    );

    if (eventRounds.isEmpty) {
      return {'BlueBoxer': 0, 'RedBoxer': 0}; // No rounds for this event
    }

    final roundIds = eventRounds.map((r) => r['id'] as int).toList();

    // Query messages belonging to any of these rounds
    // Use COUNT(*) and GROUP BY for efficiency
    final results = await db.query(
      'messages',
      columns: ['punchBy', 'COUNT(*) as count'],
      where: 'roundId IN (${List.filled(roundIds.length, '?').join(',')})',
      whereArgs: roundIds,
      groupBy: 'punchBy',
    );

    int blue = 0;
    int red = 0;
    for (final row in results) {
      final who = row['punchBy'] as String?;
      final count = row['count'] as int? ?? 0;
      if (who == 'BlueBoxer') {
        blue = count;
      } else if (who == 'RedBoxer') {
        red = count;
      }
    }
    return {'BlueBoxer': blue, 'RedBoxer': red};
  }

  /// Calculates punch counts for a specific round.
  Future<Map<String, int>> getRoundPunchCounts(int roundId) async {
    final db = await database;
    // Use COUNT(*) and GROUP BY for efficiency
    final results = await db.query(
      'messages',
      columns: ['punchBy', 'COUNT(*) as count'],
      where: 'roundId = ?',
      whereArgs: [roundId],
      groupBy: 'punchBy',
    );

    int blue = 0;
    int red = 0;
    for (final row in results) {
      final who = row['punchBy'] as String?;
      final count = row['count'] as int? ?? 0;
      if (who == 'BlueBoxer') {
        blue = count;
      } else if (who == 'RedBoxer') {
        red = count;
      }
    }
    return {'BlueBoxer': blue, 'RedBoxer': red};
  }


} // End of DatabaseHelper class

















import 'dart:math'; // Needed for random sample data
import 'package:flutter/material.dart'; // Needed for debugPrint
import 'package:sqflite/sqflite.dart';
import 'package:path/path.dart';
import 'package:path_provider/path_provider.dart';
import 'package:uuid/uuid.dart'; // Import the uuid package

// Helper function to check if a column exists (remains the same)
Future<bool> _columnExists(Database db, String table, String columnName) async {
  final columns = await db.rawQuery('PRAGMA table_info($table)');
  for (final col in columns) {
    if (col['name'] == columnName) {
      return true;
    }
  }
  return false;
}

class DatabaseHelper {
  // Singleton instance
  static final DatabaseHelper _instance = DatabaseHelper._internal();
  static Database? _database;
  final Uuid _uuid = const Uuid(); // Instantiate Uuid generator
  final Random _random = Random(); // Instantiate Random generator

  // Private constructor
  DatabaseHelper._internal();

  // Factory constructor to return the same instance
  factory DatabaseHelper() => _instance;

  // Getter to access the database
  Future<Database> get database async {
    if (_database != null) return _database!;
    _database = await _initDatabase();
    return _database!;
  }

  // --- Database Initialization and Schema ---
  // _initDatabase, _onCreate, table creation helpers, _insertDefaultSettings, _onUpgrade
  // ... (These methods remain the same as the previous version) ...
  Future<Database> _initDatabase() async {
    final directory = await getApplicationDocumentsDirectory();
    final path = join(directory.path, 'messages.db');
    return await openDatabase(
      path,
      version: 7,
      onOpen: (db) async {
        await db.execute("PRAGMA foreign_keys = ON");
      },
      onCreate: _onCreate,
      onUpgrade: _onUpgrade,
    );
  }

  Future<void> _onCreate(Database db, int version) async {
    await db.execute("PRAGMA foreign_keys = ON");
    debugPrint("Running _onCreate for database version $version");
    await _createMatchesTable(db);
    await _createEventsTable(db);
    await _createRoundsTable(db);
    await _createMessagesTable(db);
    await _createTrainingDataTable(db);
    await _createSettingsTable(db);
    await _insertDefaultSettings(db);
    debugPrint("_onCreate complete.");
  }

  Future<void> _createMatchesTable(Database db) async {
    await db.execute(
      ''' CREATE TABLE matches( id INTEGER PRIMARY KEY AUTOINCREMENT, matchName TEXT, matchDate TEXT, rounds INTEGER, finishedAtRound INTEGER, totalTime TEXT, roundTime INTEGER, breakTime INTEGER ) ''',
    );
    debugPrint("Table 'matches' created.");
  }

  Future<void> _createEventsTable(Database db) async {
    await db.execute(
      ''' CREATE TABLE events( id TEXT PRIMARY KEY, timestamp INTEGER, matchId INTEGER, winner TEXT, FOREIGN KEY (matchId) REFERENCES matches(id) ON DELETE CASCADE ) ''',
    );
    debugPrint("Table 'events' created.");
  }

  Future<void> _createRoundsTable(Database db) async {
    await db.execute(
      ''' CREATE TABLE rounds( id INTEGER PRIMARY KEY AUTOINCREMENT, eventId TEXT, punchCount INTEGER, matchId INTEGER, round INTEGER, timestamp INTEGER, FOREIGN KEY (matchId) REFERENCES matches(id) ON DELETE CASCADE, FOREIGN KEY (eventId) REFERENCES events(id) ON DELETE CASCADE, UNIQUE(eventId, round) ) ''',
    );
    debugPrint("Table 'rounds' created.");
  }

  Future<void> _createMessagesTable(Database db) async {
    await db.execute(
      ''' CREATE TABLE messages( id INTEGER PRIMARY KEY AUTOINCREMENT, device TEXT, punchBy TEXT, punchCount TEXT, timestamp TEXT, sensorValue TEXT, roundId INTEGER, matchId INTEGER, FOREIGN KEY (roundId) REFERENCES rounds(id) ON DELETE CASCADE, FOREIGN KEY (matchId) REFERENCES matches(id) ON DELETE CASCADE ) ''',
    );
    debugPrint("Table 'messages' created.");
  }

  Future<void> _createTrainingDataTable(Database db) async {
    await db.execute(
      ''' CREATE TABLE trainingdata( id INTEGER PRIMARY KEY AUTOINCREMENT, device TEXT, punchBy TEXT, punchCount TEXT, timestamp TEXT, sensorValue TEXT, roundId INTEGER ) ''',
    );
    debugPrint("Table 'trainingdata' created.");
  }

  Future<void> _createSettingsTable(Database db) async {
    await db.execute(
      ''' CREATE TABLE settings( id INTEGER PRIMARY KEY, fsrSensitivity INTEGER, fsrThreshold INTEGER, roundTime INTEGER, breakTime INTEGER, secondsBeforeRoundBegins INTEGER, rounds INTEGER ) ''',
    );
    debugPrint("Table 'settings' created.");
  }

  Future<void> _insertDefaultSettings(Database db) async {
    await db.insert('settings', {
      'id': 1,
      'fsrSensitivity': 800,
      'fsrThreshold': 200,
      'roundTime': 180,
      'breakTime': 60,
      'secondsBeforeRoundBegins': 5,
      'rounds': 3,
    }, conflictAlgorithm: ConflictAlgorithm.replace);
    debugPrint("Default settings inserted/replaced.");
  }

  Future<void> _onUpgrade(Database db, int oldVersion, int newVersion) async {
    debugPrint("Upgrading database from version $oldVersion to $newVersion");
    if (oldVersion < 4) {
      if (!await _columnExists(db, 'messages', 'device')) {
        await db.execute('ALTER TABLE messages ADD COLUMN device TEXT');
        debugPrint("Added 'device' column to messages table.");
      }
    }
    if (oldVersion < 5) {
      if (!await _columnExists(db, 'settings', 'fsrThreshold')) {
        await db.execute(
          'ALTER TABLE settings ADD COLUMN fsrThreshold INTEGER DEFAULT 200',
        );
        debugPrint("Added 'fsrThreshold' column to settings table.");
      }
      if (!await _columnExists(db, 'settings', 'roundTime')) {
        await db.execute(
          'ALTER TABLE settings ADD COLUMN roundTime INTEGER DEFAULT 180',
        );
        debugPrint("Added 'roundTime' column to settings table.");
      }
      if (!await _columnExists(db, 'settings', 'breakTime')) {
        await db.execute(
          'ALTER TABLE settings ADD COLUMN breakTime INTEGER DEFAULT 60',
        );
        debugPrint("Added 'breakTime' column to settings table.");
      }
      if (!await _columnExists(db, 'settings', 'secondsBeforeRoundBegins')) {
        await db.execute(
          'ALTER TABLE settings ADD COLUMN secondsBeforeRoundBegins INTEGER DEFAULT 5',
        );
        debugPrint(
          "Added 'secondsBeforeRoundBegins' column to settings table.",
        );
      }
    }
    if (oldVersion < 6) {
      if (!await _columnExists(db, 'messages', 'punchBy')) {
        await db.execute('ALTER TABLE messages ADD COLUMN punchBy TEXT');
        debugPrint("Added 'punchBy' column to messages table.");
      }
    }
    if (oldVersion < 7) {
      if (!await _columnExists(db, 'settings', 'rounds')) {
        await db.execute(
          'ALTER TABLE settings ADD COLUMN rounds INTEGER DEFAULT 3',
        );
        debugPrint("Added 'rounds' column to settings table.");
      }
    }
    debugPrint("Database upgrade complete.");
  }

  // --- Sample Data Insertion ---

  /// Clears all data from relevant tables. Call before inserting sample data.
  Future<void> _clearAllData() async {
    final db = await database;
    debugPrint("Clearing existing data...");
    await db.delete('messages');
    await db.delete('trainingdata');
    await db.delete('rounds');
    await db.delete('events');
    await db.delete('matches');
    debugPrint("Data cleared.");
  }

  /// **NEW HELPER:** Formats total seconds into HH:MM:SS string.
  String _formatSecondsToTimeString(int totalSeconds) {
    if (totalSeconds < 0) totalSeconds = 0; // Ensure non-negative
    int s = totalSeconds % 60;
    int m = (totalSeconds ~/ 60) % 60;
    int h = totalSeconds ~/ 3600;
    return "${h.toString().padLeft(2, '0')}:${m.toString().padLeft(2, '0')}:${s.toString().padLeft(2, '0')}";
  }

  /// Inserts a comprehensive set of sample data for testing.
  Future<void> insertComprehensiveSampleData() async {
    final db = await database;
    await _clearAllData();
    await _insertDefaultSettings(db);

    debugPrint("Inserting comprehensive sample data...");

    int round1_1 = 0, round2_1 = 0, round2_2 = 0, round2_3 = 0;
    int round3_1 = 0, round3_2 = 0, round3_3 = 0, round3_4 = 0, round3_5 = 0;
    int shortR1 = 0, shortR2 = 0;
    List<int> allInsertedRoundIds = [];

    try {
      // 1. Insert Sample Matches (Store data locally to access roundTime later)
      List<Map<String, dynamic>> sampleMatchesData = [
        {
        'matchName': '1 Round Practice Match',
        'matchDate': '2025-03-20',
        'rounds': 1,
        'finishedAtRound': 0,
        'totalTime': '00:00',
        'roundTime': 1,
        'breakTime': 10,
      },
      {
        'matchName': '2 Rounds Practice Match',
        'matchDate': '2024-11-20',
        'rounds': 2,
        'finishedAtRound': 0,
        'totalTime': '00:00',
        'roundTime': 1,
        'breakTime': 10,
      },
      {
        'matchName': '5 Rounds Practice Match',
        'matchDate': '2024-11-20',
        'rounds': 5,
        'finishedAtRound': 0,
        'totalTime': '00:00',
        'roundTime': 3,
        'breakTime': 120,
      },
      {
        'matchName': 'Test Quick Match',
        'matchDate': '2025-03-07',
        'rounds': 2,
        'finishedAtRound': 0,
        'totalTime': '00:00',
        'roundTime': 1,
        'breakTime': 10,
      },
      {
        'matchName': 'Championship Match',
        'matchDate': '2024-11-28',
        'rounds': 12,
        'finishedAtRound': 0,
        'totalTime': '00:00',
        'roundTime': 3,
        'breakTime': 120,
      },
      {
        'matchName': 'BlueBoxer vs RedBoxer',
        'matchDate': '2025-03-07',
        'rounds': 3,
        'finishedAtRound': 0,
        'totalTime': '00:00',
        'roundTime': 3,
        'breakTime': 120,
      },
      {
        'matchName': 'Themis vs Nick',
        'matchDate': '2025-03-07',
        'rounds': 5,
        'finishedAtRound': 0,
        'totalTime': '00:00',
        'roundTime': 3,
        'breakTime': 120,
      },
      {
        'matchName': 'Themis vs Panos',
        'matchDate': '2024-11-25',
        'rounds': 7,
        'finishedAtRound': 0,
        'totalTime': '00:00',
        'roundTime': 3,
        'breakTime': 120,
      },
        {
          'matchName': 'Quick Spar (1 Round)',
          'matchDate': '2025-04-27',
          'rounds': 1,
          'finishedAtRound': 1,
          'totalTime': '03:15',
          'roundTime': 1,
          'breakTime': 10,
        },
        {
          'matchName': 'Standard Bout (3 Rounds)',
          'matchDate': '2025-04-27',
          'rounds': 3,
          'finishedAtRound': 3,
          'totalTime': '11:00',
          'roundTime': 1,
          'breakTime': 10,
        },
        {
          'matchName': 'Short Rounds (2 Rounds)',
          'matchDate': '2025-04-26',
          'rounds': 2,
          'finishedAtRound': 0,
          'totalTime': '00:00',
          'roundTime': 1,
          'breakTime': 10,
        },
        {
          'matchName': 'Endurance Test (5 Rounds)',
          'matchDate': '2025-04-25',
          'rounds': 5,
          'finishedAtRound': 5,
          'totalTime': '19:00',
          'roundTime': 1,
          'breakTime': 10,
        },

        {
          'matchName': '' /* ... other matches ... */,
        }, // Add more sample matches as needed
      ];
      List<int> matchIds = [];
      List<Map<String, dynamic>> insertedMatchesDetails =
          []; // Store details with ID

      for (var matchData in sampleMatchesData) {
        final id = await insertMatch(
          /* ... details ... */
          matchName: matchData['matchName'],
          rounds: matchData['rounds'],
          matchDate: matchData['matchDate'],
          roundTime: matchData['roundTime'],
          breakTime: matchData['breakTime'],
        );
        matchIds.add(id);
        insertedMatchesDetails.add({...matchData, 'id': id});
        if (matchData['finishedAtRound'] > 0) {
          await updateEditMatch(
            id: id,
            /* ... rest ... */
            matchName: matchData['matchName'],
            matchDate: matchData['matchDate'],
            rounds: matchData['rounds'],
            finishedAtRound: matchData['finishedAtRound'],
            totalTime: matchData['totalTime'],
            roundTime: matchData['roundTime'],
            breakTime: matchData['breakTime'],
          );
        }
      }
      debugPrint("Inserted ${matchIds.length} sample matches.");

      // 2. Insert Sample Events
      List<String> eventIds = [];
      if (matchIds.length >= 4) {
        String event1Id = await insertEvent(
          matchId: matchIds[0],
          winner: 'BlueBoxer',
        );
        eventIds.add(event1Id);
        String event2Id = await insertEvent(
          matchId: matchIds[1],
          winner: 'RedBoxer',
        );
        eventIds.add(event2Id);
        String eventShortround = await insertEvent(
          matchId: matchIds[2],
          winner: null,
        );
        eventIds.add(eventShortround);
        String event3Id = await insertEvent(
          matchId: matchIds[3],
          winner: 'Draw',
        );
        eventIds.add(event3Id);
        debugPrint("Inserted ${eventIds.length} sample events.");
      } else {
        /* Warning */
      }

      // 3. Insert Sample Rounds
      if (eventIds.length >= 4 && matchIds.length >= 4) {
        round1_1 = await insertRound(
          matchId: matchIds[0],
          eventId: eventIds[0],
          round: 1,
        );
        if (round1_1 > 0) allInsertedRoundIds.add(round1_1);
        round2_1 = await insertRound(
          matchId: matchIds[1],
          eventId: eventIds[1],
          round: 1,
        );
        if (round2_1 > 0) allInsertedRoundIds.add(round2_1);
        round2_2 = await insertRound(
          matchId: matchIds[1],
          eventId: eventIds[1],
          round: 2,
        );
        if (round2_2 > 0) allInsertedRoundIds.add(round2_2);
        round2_3 = await insertRound(
          matchId: matchIds[1],
          eventId: eventIds[1],
          round: 3,
        );
        if (round2_3 > 0) allInsertedRoundIds.add(round2_3);
        shortR1 = await insertRound(
          matchId: matchIds[2],
          eventId: eventIds[2],
          round: 1,
        );
        if (shortR1 > 0) allInsertedRoundIds.add(shortR1);
        shortR2 = await insertRound(
          matchId: matchIds[2],
          eventId: eventIds[2],
          round: 2,
        );
        if (shortR2 > 0) allInsertedRoundIds.add(shortR2);
        round3_1 = await insertRound(
          matchId: matchIds[3],
          eventId: eventIds[3],
          round: 1,
        );
        if (round3_1 > 0) allInsertedRoundIds.add(round3_1);
        round3_2 = await insertRound(
          matchId: matchIds[3],
          eventId: eventIds[3],
          round: 2,
        );
        if (round3_2 > 0) allInsertedRoundIds.add(round3_2);
        round3_3 = await insertRound(
          matchId: matchIds[3],
          eventId: eventIds[3],
          round: 3,
        );
        if (round3_3 > 0) allInsertedRoundIds.add(round3_3);
        round3_4 = await insertRound(
          matchId: matchIds[3],
          eventId: eventIds[3],
          round: 4,
        );
        if (round3_4 > 0) allInsertedRoundIds.add(round3_4);
        round3_5 = await insertRound(
          matchId: matchIds[3],
          eventId: eventIds[3],
          round: 5,
        );
        if (round3_5 > 0) allInsertedRoundIds.add(round3_5);
      } else {
        /* Warning */
      }
      debugPrint("Inserted ${allInsertedRoundIds.length} sample rounds.");

      // 4. Insert Sample Messages for some Rounds
      int messagesInserted = 0;

      // ---> Messages for Round 1 of Match 0 (roundTime = 180s) <---
      if (round1_1 > 0 && insertedMatchesDetails.isNotEmpty) {
        final matchDetails = insertedMatchesDetails.firstWhere(
          (m) => m['id'] == matchIds[0],
        );
        int roundTimeSeconds = matchDetails['roundTime'] as int;
        int currentSecondsInRound = 0; // Start time for this round
        debugPrint(
          "Inserting messages for round1_1 (Match 0), Round Time: $roundTimeSeconds seconds",
        );

        // Loop for BlueBoxer punches
        int bluePunchCount = 15 + _random.nextInt(10);
        for (int i = 1; i <= bluePunchCount; i++) {
          int increment = 1 + _random.nextInt(5); // Advance time by 1-5 seconds
          currentSecondsInRound += increment;
          if (currentSecondsInRound >= roundTimeSeconds) {
            break; // Stop if round time exceeded
          }

          String timeString = _formatSecondsToTimeString(
            currentSecondsInRound,
          ); // <<< Use Helper
          await insertMessage(
            'BlueBoxer',
            'RedBoxer',
            i.toString(),
            timeString,
            (_random.nextInt(500) + 300).toString(),
            round1_1,
            matchIds[0],
          );
          messagesInserted++;
        }

        // Loop for RedBoxer punches (reset time or continue?) Let's interleave roughly - use same counter
        int redPunchCount = 10 + _random.nextInt(8);
        for (int i = 1; i <= redPunchCount; i++) {
          int increment =
              1 + _random.nextInt(6); // Advance time slightly differently
          currentSecondsInRound += increment;
          if (currentSecondsInRound >= roundTimeSeconds) {
            break; // Stop if round time exceeded
          }

          String timeString = _formatSecondsToTimeString(
            currentSecondsInRound,
          ); // <<< Use Helper
          await insertMessage(
            'RedBoxer',
            'BlueBoxer',
            i.toString(),
            timeString,
            (_random.nextInt(400) + 250).toString(),
            round1_1,
            matchIds[0],
          );
          messagesInserted++;
        }
      }

      // ---> Messages for Round 2 of Match 1 (roundTime = 180s) <---
      if (round2_2 > 0 && insertedMatchesDetails.length >= 2) {
        final matchDetails = insertedMatchesDetails.firstWhere(
          (m) => m['id'] == matchIds[1],
        );
        int roundTimeSeconds = matchDetails['roundTime'] as int;
        int currentSecondsInRound = 0; // Start time for this round
        debugPrint(
          "Inserting messages for round2_2 (Match 1), Round Time: $roundTimeSeconds seconds",
        );

        int bluePunchCount = 20 + _random.nextInt(15);
        for (int i = 1; i <= bluePunchCount; i++) {
          int increment = 1 + _random.nextInt(4);
          currentSecondsInRound += increment;
          if (currentSecondsInRound >= roundTimeSeconds) break;
          String timeString = _formatSecondsToTimeString(
            currentSecondsInRound,
          ); // <<< Use Helper
          await insertMessage(
            'BlueBoxer',
            'RedBoxer',
            i.toString(),
            timeString,
            (_random.nextInt(600) + 350).toString(),
            round2_2,
            matchIds[1],
          );
          messagesInserted++;
        }

        int redPunchCount = 25 + _random.nextInt(10);
        for (int i = 1; i <= redPunchCount; i++) {
          int increment = 1 + _random.nextInt(5);
          currentSecondsInRound += increment;
          if (currentSecondsInRound >= roundTimeSeconds) break;
          String timeString = _formatSecondsToTimeString(
            currentSecondsInRound,
          ); // <<< Use Helper
          await insertMessage(
            'RedBoxer',
            'BlueBoxer',
            i.toString(),
            timeString,
            (_random.nextInt(550) + 400).toString(),
            round2_2,
            matchIds[1],
          );
          messagesInserted++;
        }
      }

      // ---> Messages for Round 1 of Short Round Match (Match 2, roundTime = 60s) <---
      if (shortR1 > 0 && insertedMatchesDetails.length >= 3) {
        final matchDetails = insertedMatchesDetails.firstWhere(
          (m) => m['id'] == matchIds[2],
        );
        int roundTimeSeconds = matchDetails['roundTime'] as int; // Should be 60
        int currentSecondsInRound = 0; // Start time for this round
        debugPrint(
          "Inserting messages for shortR1 (Match 2), Round Time: $roundTimeSeconds seconds",
        );

        int bluePunchCount = 8 + _random.nextInt(7);
        for (int i = 1; i <= bluePunchCount; i++) {
          int increment = 1 + _random.nextInt(3); // Smaller increments
          currentSecondsInRound += increment;
          if (currentSecondsInRound >= roundTimeSeconds) break;
          String timeString = _formatSecondsToTimeString(
            currentSecondsInRound,
          ); // <<< Use Helper
          await insertMessage(
            'BlueBoxer',
            'RedBoxer',
            i.toString(),
            timeString,
            (_random.nextInt(400) + 200).toString(),
            shortR1,
            matchIds[2],
          );
          messagesInserted++;
        }

        int redPunchCount = 7 + _random.nextInt(8);
        for (int i = 1; i <= redPunchCount; i++) {
          int increment = 1 + _random.nextInt(4);
          currentSecondsInRound += increment;
          if (currentSecondsInRound >= roundTimeSeconds) break;
          String timeString = _formatSecondsToTimeString(
            currentSecondsInRound,
          ); // <<< Use Helper
          await insertMessage(
            'RedBoxer',
            'BlueBoxer',
            i.toString(),
            timeString,
            (_random.nextInt(350) + 250).toString(),
            shortR1,
            matchIds[2],
          );
          messagesInserted++;
        }
      }

      // ---> Messages for Round 3 of Match 3 (Endurance Test, roundTime = 180s) <---
      if (round3_3 > 0 && insertedMatchesDetails.length >= 4) {
        final matchDetails = insertedMatchesDetails.firstWhere(
          (m) => m['id'] == matchIds[3],
        );
        int roundTimeSeconds = matchDetails['roundTime'] as int;
        int currentSecondsInRound = 0; // Start time for this round
        debugPrint(
          "Inserting messages for round3_3 (Match 3), Round Time: $roundTimeSeconds seconds",
        );

        int bluePunchCount = 18 + _random.nextInt(12);
        for (int i = 1; i <= bluePunchCount; i++) {
          int increment = 1 + _random.nextInt(5);
          currentSecondsInRound += increment;
          if (currentSecondsInRound >= roundTimeSeconds) break;
          String timeString = _formatSecondsToTimeString(
            currentSecondsInRound,
          ); // <<< Use Helper
          await insertMessage(
            'BlueBoxer',
            'RedBoxer',
            i.toString(),
            timeString,
            (_random.nextInt(500) + 320).toString(),
            round3_3,
            matchIds[3],
          );
          messagesInserted++;
        }

        int redPunchCount = 16 + _random.nextInt(10);
        for (int i = 1; i <= redPunchCount; i++) {
          int increment = 1 + _random.nextInt(6);
          currentSecondsInRound += increment;
          if (currentSecondsInRound >= roundTimeSeconds) break;
          String timeString = _formatSecondsToTimeString(
            currentSecondsInRound,
          ); // <<< Use Helper
          await insertMessage(
            'RedBoxer',
            'BlueBoxer',
            i.toString(),
            timeString,
            (_random.nextInt(520) + 380).toString(),
            round3_3,
            matchIds[3],
          );
          messagesInserted++;
        }
      }
      debugPrint("Inserted $messagesInserted sample messages.");

      // 5. Insert Sample Training Data (Timestamp remains fully random HH:MM:SS)
      int trainingDataInserted = 0;
      for (int i = 0; i < 50; i++) {
        String device = _random.nextBool() ? 'BlueBoxer' : 'RedBoxer';
        String punchBy = device == 'BlueBoxer' ? 'RedBoxer' : 'BlueBoxer';
        // Keep timestamp fully random (00:00:00 to 23:59:59) for training data
        String timeString =
            "${_random.nextInt(24).toString().padLeft(2, '0')}:${_random.nextInt(60).toString().padLeft(2, '0')}:${_random.nextInt(60).toString().padLeft(2, '0')}";
        await insertTrainingData(
          device,
          punchBy,
          (i + 1).toString(),
          timeString,
          (_random.nextInt(800) + 100).toString(),
        );
        trainingDataInserted++;
      }
      debugPrint(
        "Inserted $trainingDataInserted sample training data records.",
      );

      debugPrint("Comprehensive sample data insertion COMPLETE.");
    } catch (e, stacktrace) {
      debugPrint("Error inserting sample data: $e");
      debugPrint("Stacktrace: $stacktrace");
    }
  }

  // --- METHOD SIGNATURES AND UTILITY METHODS --- (No changes needed below this line)
  // Messages
  Future<void> insertMessage(
    String device,
    String oppositeDevice,
    String punchCount,
    String timestamp,
    String sensorValue,
    int roundId,
    int matchId,
  ) async {
    final db = await database;
    await db.insert('messages', {
      'device': device,
      'punchBy': oppositeDevice,
      'punchCount': punchCount,
      'timestamp': timestamp,
      'sensorValue': sensorValue,
      'roundId': roundId,
      'matchId': matchId,
    });
  }

  Future<List<Map<String, dynamic>>> fetchMessages() async {
    final db = await database;
    return await db.query('messages', orderBy: 'id DESC');
  }

  Future<List<Map<String, dynamic>>> fetchMessagesByMatchId(int matchId) async {
    final db = await database;
    return await db.query(
      'messages',
      where: 'matchId = ?',
      whereArgs: [matchId],
      orderBy: 'id DESC',
    );
  }

  Future<List<Map<String, dynamic>>> fetchMessagesByRoundId(int roundId) async {
    final db = await database;
    return await db.query(
      'messages',
      where: 'roundId = ?',
      whereArgs: [roundId],
      orderBy: 'id DESC',
    );
  }

  Future<void> clearMessages() async {
    final db = await database;
    await db.delete('messages');
    debugPrint("Cleared messages table.");
  }

  // Training Data
  Future<void> insertTrainingData(
    String device,
    String punchBy,
    String punchCount,
    String timestamp,
    String sensorValue,
  ) async {
    final db = await database;
    await db.insert('trainingdata', {
      'device': device,
      'punchBy': punchBy,
      'punchCount': punchCount,
      'timestamp': timestamp,
      'sensorValue': sensorValue,
    });
  }

  Future<List<Map<String, dynamic>>> fetchTrainingData() async {
    final db = await database;
    return await db.query('trainingdata', orderBy: 'id DESC');
  }

  Future<void> clearTrainingData() async {
    final db = await database;
    await db.delete('trainingdata');
    debugPrint("Cleared trainingdata table.");
  }

  // Settings
  Future<void> upsertSettings({
    required int fsrSensitivity,
    required int fsrThreshold,
    required int rounds,
    required int roundTime,
    required int breakTime,
    required int secondsBeforeRoundBegins,
  }) async {
    final db = await database;
    await db.insert('settings', {
      'id': 1,
      'fsrSensitivity': fsrSensitivity,
      'fsrThreshold': fsrThreshold,
      'rounds': rounds,
      'roundTime': roundTime,
      'breakTime': breakTime,
      'secondsBeforeRoundBegins': secondsBeforeRoundBegins,
    }, conflictAlgorithm: ConflictAlgorithm.replace);
    debugPrint("Settings upserted.");
  }

  Future<Map<String, dynamic>?> fetchSettings() async {
    final db = await database;
    final List<Map<String, dynamic>> settings = await db.query(
      'settings',
      where: 'id = ?',
      whereArgs: [1],
      limit: 1,
    );
    if (settings.isNotEmpty) {
      return settings.first;
    } else {
      debugPrint("Warning: Settings not found, returning null.");
      return null;
    }
  }

  Future<void> clearSettings() async {
    final db = await database;
    await _insertDefaultSettings(db);
    debugPrint("Settings reset to default.");
  }

  // Matches
  Future<int> insertMatch({
    required String matchName,
    required int rounds,
    required String matchDate,
    required int roundTime,
    required int breakTime,
  }) async {
    final db = await database;
    final Map<String, dynamic> matchData = {
      'matchName': matchName,
      'rounds': rounds,
      'matchDate': matchDate,
      'roundTime': roundTime,
      'breakTime': breakTime,
      'finishedAtRound': 0,
      'totalTime': '00:00',
    };
    final id = await db.insert('matches', matchData);
    debugPrint("Inserted match with ID: $id");
    return id;
  }

  Future<void> updateEditMatch({
    required int id,
    required String matchName,
    required String matchDate,
    required int rounds,
    required int finishedAtRound,
    required String totalTime,
    required int roundTime,
    required int breakTime,
  }) async {
    final db = await database;
    await db.update(
      'matches',
      {
        'matchName': matchName,
        'matchDate': matchDate,
        'rounds': rounds,
        'finishedAtRound': finishedAtRound,
        'totalTime': totalTime,
        'roundTime': roundTime,
        'breakTime': breakTime,
      },
      where: 'id = ?',
      whereArgs: [id],
    );
    debugPrint("Updated match with ID: $id");
  }

  Future<List<Map<String, dynamic>>> fetchMatches() async {
    final db = await database;
    return await db.query('matches', orderBy: 'id ASC');
  }

  Future<void> deleteMatch(int id) async {
    final db = await database;
    int count = await db.delete('matches', where: 'id = ?', whereArgs: [id]);
    if (count > 0) {
      debugPrint("Deleted match with ID: $id and related data.");
    } else {
      debugPrint("Match with ID: $id not found for deletion.");
    }
  }

  Future<Map<String, dynamic>?> fetchMatchById(int id) async {
    final db = await database;
    final result = await db.query(
      'matches',
      where: 'id = ?',
      whereArgs: [id],
      limit: 1,
    );
    return result.isNotEmpty ? result.first : null;
  }

  Future<void> clearMatches() async {
    final db = await database;
    await db.delete('matches');
    debugPrint("Cleared matches table and related data.");
  }

  Future<void> insertSampleMatchesOnly() async {
    debugPrint("Inserting sample matches ONLY...");
    List<Map<String, dynamic>> sampleMatches = [
      {
        'matchName': 'Basic 1',
        'rounds': 1,
        'matchDate': '2025-01-01',
        'roundTime': 60,
        'breakTime': 10,
      },
      {
        'matchName': 'Basic 2',
        'rounds': 3,
        'matchDate': '2025-01-02',
        'roundTime': 180,
        'breakTime': 60,
      },
    ];
    int count = 0;
    for (var match in sampleMatches) {
      await insertMatch(
        matchName: match['matchName'],
        rounds: match['rounds'],
        matchDate: match['matchDate'],
        roundTime: match['roundTime'],
        breakTime: match['breakTime'],
      );
      count++;
    }
    debugPrint("Inserted $count sample matches only.");
  }

  // Events
  Future<String> insertEvent({required int matchId, String? winner}) async {
    final db = await database;
    String eventId = _uuid.v4();
    await db.insert('events', {
      'id': eventId,
      'timestamp': DateTime.now().millisecondsSinceEpoch,
      'matchId': matchId,
      'winner': winner,
    });
    debugPrint("Inserted event $eventId for Match ID $matchId");
    return eventId;
  }

  Future<List<Map<String, dynamic>>> fetchEvents() async {
    final db = await database;
    return await db.query('events', orderBy: 'timestamp DESC');
  }

  Future<List<Map<String, dynamic>>> fetchEventsByMatchId(int matchId) async {
    final db = await database;
    return await db.query(
      'events',
      where: 'matchId = ?',
      whereArgs: [matchId],
      orderBy: 'timestamp DESC',
    );
  }

  Future<void> clearEvents() async {
    final db = await database;
    await db.delete('events');
    debugPrint("Cleared events table.");
  }

  Future<void> updateCurrentEventWinner(String eventId, String? winner) async {
    final db = await database;
    await db.update(
      'events',
      {'winner': winner},
      where: 'id = ?',
      whereArgs: [eventId],
    );
    debugPrint("Updated winner for event $eventId");
  }

  // Rounds
  Future<int> insertRound({
    required int matchId,
    required int round,
    required String? eventId,
  }) async {
    final db = await database;
    final roundData = {
      'matchId': matchId,
      'round': round,
      'eventId': eventId,
      'timestamp': DateTime.now().millisecondsSinceEpoch,
    };
    int id = 0;
    try {
      id = await db.insert('rounds', roundData);
      debugPrint("Inserted round $round for Event $eventId, Round ID: $id");
    } on DatabaseException catch (e) {
      if (e.isUniqueConstraintError()) {
        debugPrint("Error: Round $round for Event $eventId already exists.");
      } else {
        debugPrint("Database error inserting round: $e");
      }
    }
    return id;
  }

  Future<List<Map<String, dynamic>>> fetchRounds() async {
    final db = await database;
    List<Map<String, dynamic>> rounds = await db.query(
      'rounds',
      orderBy: 'id DESC',
    );
    return rounds.map((round) {
      final timestamp = round['timestamp'];
      String humanReadableTimestamp = "N/A";
      if (timestamp != null && timestamp is int) {
        try {
          var date = DateTime.fromMillisecondsSinceEpoch(timestamp);
          humanReadableTimestamp =
              "${date.year}-${date.month.toString().padLeft(2, '0')}-${date.day.toString().padLeft(2, '0')} ${date.hour.toString().padLeft(2, '0')}:${date.minute.toString().padLeft(2, '0')}:${date.second.toString().padLeft(2, '0')}";
        } catch (e) {
          debugPrint("Error formatting timestamp $timestamp: $e");
        }
      }
      var mutableRound = Map<String, dynamic>.from(round);
      mutableRound['humanReadableTimestamp'] = humanReadableTimestamp;
      return mutableRound;
    }).toList();
  }

  Future<void> clearRounds() async {
    final db = await database;
    await db.delete('rounds');
    debugPrint("Cleared rounds table.");
  }

  // Utilities
  Future<Map<String, int>> getEventPunchCounts(String eventId) async {
    final db = await database;
    final eventRounds = await db.query(
      'rounds',
      columns: ['id'],
      where: 'eventId = ?',
      whereArgs: [eventId],
    );
    if (eventRounds.isEmpty) {
      return {'BlueBoxer': 0, 'RedBoxer': 0};
    }
    final roundIds = eventRounds.map((r) => r['id'] as int).toList();
    final messages = await db.query(
      'messages',
      columns: ['punchBy'],
      where: 'roundId IN (${List.filled(roundIds.length, '?').join(',')})',
      whereArgs: roundIds,
    );
    int blue = 0;
    int red = 0;
    for (final msg in messages) {
      final who = msg['punchBy'] as String?;
      if (who == 'BlueBoxer') {
        blue++;
      } else if (who == 'RedBoxer') {
        red++;
      }
    }
    return {'BlueBoxer': blue, 'RedBoxer': red};
  }

  Future<Map<String, int>> getRoundPunchCounts(int roundId) async {
    final db = await database;
    final messages = await db.query(
      'messages',
      columns: ['punchBy'],
      where: 'roundId = ?',
      whereArgs: [roundId],
    );
    int blue = 0;
    int red = 0;
    for (final msg in messages) {
      final who = msg['punchBy'] as String?;
      if (who == 'BlueBoxer') {
        blue++;
      } else if (who == 'RedBoxer') {
        red++;
      }
    }
    return {'BlueBoxer': blue, 'RedBoxer': red};
  }
} // End of DatabaseHelper class



// ----------------------------------------------------------------------


import 'dart:math'; // Needed for random sample data
import 'package:flutter/material.dart'; // Needed for debugPrint
import 'package:sqflite/sqflite.dart';
import 'package:path/path.dart';
import 'package:path_provider/path_provider.dart';
import 'package:uuid/uuid.dart'; // Import the uuid package

// Helper function to check if a column exists (remains the same)
Future<bool> _columnExists(Database db, String table, String columnName) async {
  final columns = await db.rawQuery('PRAGMA table_info($table)');
  for (final col in columns) {
    if (col['name'] == columnName) {
      return true;
    }
  }
  return false;
}

class DatabaseHelper {
  // Singleton instance
  static final DatabaseHelper _instance = DatabaseHelper._internal();
  static Database? _database;
  final Uuid _uuid = const Uuid(); // Instantiate Uuid generator
  final Random _random = Random(); // Instantiate Random generator

  // Private constructor
  DatabaseHelper._internal();

  // Factory constructor to return the same instance
  factory DatabaseHelper() => _instance;

  // Getter to access the database
  Future<Database> get database async {
    if (_database != null) return _database!;
    _database = await _initDatabase();
    return _database!;
  }

  // --- Database Initialization and Schema ---
  // _initDatabase, _onCreate, table creation helpers, _insertDefaultSettings, _onUpgrade
  // ... (These methods remain the same as the previous version) ...
  Future<Database> _initDatabase() async {
    final directory = await getApplicationDocumentsDirectory();
    final path = join(directory.path, 'messages.db');
    return await openDatabase(
      path,
      version: 7, // Keep version consistent or increment if schema changes
      onOpen: (db) async {
        await db.execute("PRAGMA foreign_keys = ON");
      },
      onCreate: _onCreate,
      onUpgrade: _onUpgrade,
    );
  }

  Future<void> _onCreate(Database db, int version) async {
    await db.execute("PRAGMA foreign_keys = ON");
    debugPrint("Running _onCreate for database version $version");
    await _createMatchesTable(db);
    await _createEventsTable(db);
    await _createRoundsTable(db);
    await _createMessagesTable(db);
    await _createTrainingDataTable(db);
    await _createSettingsTable(db);
    await _insertDefaultSettings(db);
    debugPrint("_onCreate complete.");
  }

  Future<void> _createMatchesTable(Database db) async {
    await db.execute(
      '''
      CREATE TABLE matches(
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        matchName TEXT,
        matchDate TEXT,
        rounds INTEGER,
        finishedAtRound INTEGER,
        totalTime TEXT,
        roundTime INTEGER, -- Duration of each round in seconds
        breakTime INTEGER  -- Duration of break between rounds in seconds
      )
      ''',
    );
    debugPrint("Table 'matches' created.");
  }

  Future<void> _createEventsTable(Database db) async {
    await db.execute(
      '''
      CREATE TABLE events(
        id TEXT PRIMARY KEY,
        timestamp INTEGER,
        matchId INTEGER,
        winner TEXT,
        FOREIGN KEY (matchId) REFERENCES matches(id) ON DELETE CASCADE
      )
      ''',
    );
    debugPrint("Table 'events' created.");
  }

  Future<void> _createRoundsTable(Database db) async {
    await db.execute(
      '''
      CREATE TABLE rounds(
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        eventId TEXT,
        punchCount INTEGER, -- This seems redundant if calculated from messages
        matchId INTEGER,
        round INTEGER,
        timestamp INTEGER,
        FOREIGN KEY (matchId) REFERENCES matches(id) ON DELETE CASCADE,
        FOREIGN KEY (eventId) REFERENCES events(id) ON DELETE CASCADE,
        UNIQUE(eventId, round)
      )
      ''',
    );
    debugPrint("Table 'rounds' created.");
  }

  Future<void> _createMessagesTable(Database db) async {
    await db.execute(
      '''
      CREATE TABLE messages(
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        device TEXT,         -- Who is wearing the sensor ('BlueBoxer', 'RedBoxer')
        punchBy TEXT,        -- Who threw the punch ('BlueBoxer', 'RedBoxer')
        punchCount TEXT,     -- The sequential count of this punch *by this boxer* in this round
        timestamp TEXT,      -- Time within the round (e.g., "00:01:23")
        sensorValue TEXT,    -- Sensor reading
        roundId INTEGER,
        matchId INTEGER,
        FOREIGN KEY (roundId) REFERENCES rounds(id) ON DELETE CASCADE,
        FOREIGN KEY (matchId) REFERENCES matches(id) ON DELETE CASCADE
      )
      ''',
    );
    debugPrint("Table 'messages' created.");
  }

  Future<void> _createTrainingDataTable(Database db) async {
    await db.execute(
      '''
      CREATE TABLE trainingdata(
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        device TEXT,
        punchBy TEXT,
        punchCount TEXT,
        timestamp TEXT,
        sensorValue TEXT,
        roundId INTEGER -- Might not be applicable for general training?
      )
      ''',
    );
    debugPrint("Table 'trainingdata' created.");
  }

  Future<void> _createSettingsTable(Database db) async {
    await db.execute(
      '''
      CREATE TABLE settings(
        id INTEGER PRIMARY KEY,
        fsrSensitivity INTEGER,
        fsrThreshold INTEGER,
        roundTime INTEGER,
        breakTime INTEGER,
        secondsBeforeRoundBegins INTEGER,
        rounds INTEGER
      )
      ''',
    );
    debugPrint("Table 'settings' created.");
  }

  Future<void> _insertDefaultSettings(Database db) async {
    await db.insert('settings', {
      'id': 1,
      'fsrSensitivity': 800,
      'fsrThreshold': 200,
      'roundTime': 180, // 3 minutes default round time
      'breakTime': 60, // 1 minute default break time
      'secondsBeforeRoundBegins': 5,
      'rounds': 3, // Default number of rounds
    }, conflictAlgorithm: ConflictAlgorithm.replace);
    debugPrint("Default settings inserted/replaced.");
  }

  Future<void> _onUpgrade(Database db, int oldVersion, int newVersion) async {
    debugPrint("Upgrading database from version $oldVersion to $newVersion");
    // Add upgrade logic based on version differences
    // Example: Add 'device' column if upgrading from version < 4
    if (oldVersion < 4) {
      if (!await _columnExists(db, 'messages', 'device')) {
        await db.execute('ALTER TABLE messages ADD COLUMN device TEXT');
        debugPrint("Added 'device' column to messages table.");
      }
    }
    if (oldVersion < 5) {
      // Add columns added in version 5
       if (!await _columnExists(db, 'settings', 'fsrThreshold')) {
         await db.execute(
           'ALTER TABLE settings ADD COLUMN fsrThreshold INTEGER DEFAULT 200',
         );
         debugPrint("Added 'fsrThreshold' column to settings table.");
       }
       if (!await _columnExists(db, 'settings', 'roundTime')) {
         await db.execute(
           'ALTER TABLE settings ADD COLUMN roundTime INTEGER DEFAULT 180',
         );
         debugPrint("Added 'roundTime' column to settings table.");
       }
       if (!await _columnExists(db, 'settings', 'breakTime')) {
         await db.execute(
           'ALTER TABLE settings ADD COLUMN breakTime INTEGER DEFAULT 60',
         );
         debugPrint("Added 'breakTime' column to settings table.");
       }
       if (!await _columnExists(db, 'settings', 'secondsBeforeRoundBegins')) {
         await db.execute(
           'ALTER TABLE settings ADD COLUMN secondsBeforeRoundBegins INTEGER DEFAULT 5',
         );
         debugPrint(
           "Added 'secondsBeforeRoundBegins' column to settings table.",
         );
       }
    }
     if (oldVersion < 6) {
       if (!await _columnExists(db, 'messages', 'punchBy')) {
         await db.execute('ALTER TABLE messages ADD COLUMN punchBy TEXT');
         debugPrint("Added 'punchBy' column to messages table.");
       }
     }
     if (oldVersion < 7) {
       if (!await _columnExists(db, 'settings', 'rounds')) {
         await db.execute(
           'ALTER TABLE settings ADD COLUMN rounds INTEGER DEFAULT 3',
         );
         debugPrint("Added 'rounds' column to settings table.");
       }
     }
    // Add more upgrade steps as needed for future versions
    debugPrint("Database upgrade complete.");
  }


  // --- Sample Data Insertion ---

  /// Clears all data from relevant tables. Call before inserting sample data.
  Future<void> _clearAllData() async {
    final db = await database;
    debugPrint("Clearing existing data...");
    // Delete in reverse order of dependency due to foreign keys
    await db.delete('messages');
    await db.delete('trainingdata');
    await db.delete('rounds');
    await db.delete('events');
    await db.delete('matches');
    debugPrint("Data cleared.");
  }

  /// Formats total seconds into HH:MM:SS string.
  String _formatSecondsToTimeString(int totalSeconds) {
    if (totalSeconds < 0) totalSeconds = 0; // Ensure non-negative
    int s = totalSeconds % 60;
    int m = (totalSeconds ~/ 60) % 60;
    int h = totalSeconds ~/ 3600;
    return "${h.toString().padLeft(2, '0')}:${m.toString().padLeft(2, '0')}:${s.toString().padLeft(2, '0')}";
  }

  /// **NEW HELPER:** Generates and inserts realistic, interleaved punch messages for a given round.
  Future<int> _insertRandomizedMessagesForRound({
    required Database db,
    required int roundId,
    required int matchId,
    required int roundTimeSeconds, // Duration of the round
    required int avgPunchesPerBoxer, // Average punches for variability
  }) async {
    int messagesInserted = 0;
    int bluePunchCounter = 0;
    int redPunchCounter = 0;

    // Determine total punches for the round (with some randomness)
    int bluePunches = avgPunchesPerBoxer + _random.nextInt(avgPunchesPerBoxer ~/ 2 + 1) - (avgPunchesPerBoxer ~/ 4);
    int redPunches = avgPunchesPerBoxer + _random.nextInt(avgPunchesPerBoxer ~/ 2 + 1) - (avgPunchesPerBoxer ~/ 4);
    int totalPunches = bluePunches + redPunches;
    if (totalPunches <= 0) return 0; // No punches to insert

    List<Map<String, dynamic>> punchEvents = [];

    // Generate punch events with random times and assign boxer randomly based on target counts
    List<String> boxers = List.filled(bluePunches, 'BlueBoxer') + List.filled(redPunches, 'RedBoxer');
    boxers.shuffle(_random); // Randomize the order of punches

    for (String boxer in boxers) {
       // Generate a random time within the round duration
      int timestampSeconds = _random.nextInt(roundTimeSeconds); // 0 to roundTimeSeconds-1
      String device = boxer; // The one wearing the sensor
      String punchBy = boxer; // The one throwing the punch (simplified for this example)
      // String punchBy = (boxer == 'BlueBoxer' ? 'RedBoxer' : 'BlueBoxer'); // If sensor detects opponent's punch

      punchEvents.add({
        'device': device,
        'punchBy': punchBy,
        'timestampSeconds': timestampSeconds,
        'sensorValue': (_random.nextInt(600) + 200).toString(), // Random sensor value
      });
    }


    // Sort punches chronologically
    punchEvents.sort((a, b) => (a['timestampSeconds'] as int).compareTo(b['timestampSeconds'] as int));

    // Insert sorted punches with correct sequential counts per boxer
    for (var punchEvent in punchEvents) {
      String currentPunchCount;
      if (punchEvent['punchBy'] == 'BlueBoxer') {
        bluePunchCounter++;
        currentPunchCount = bluePunchCounter.toString();
      } else {
        redPunchCounter++;
        currentPunchCount = redPunchCounter.toString();
      }

      String timeString = _formatSecondsToTimeString(punchEvent['timestampSeconds']);

      await insertMessage(
        punchEvent['device'],
        punchEvent['punchBy'], // Assuming punchBy is the same as device for simplicity here
        currentPunchCount,
        timeString,
        punchEvent['sensorValue'],
        roundId,
        matchId,
      );
      messagesInserted++;
    }
    return messagesInserted;
  }


  /// Inserts a comprehensive set of sample data for testing.
  Future<void> insertComprehensiveSampleData() async {
    final db = await database;
    await _clearAllData();
    await _insertDefaultSettings(db); // Ensure settings are present

    debugPrint("Inserting comprehensive sample data...");

    // Store details of inserted matches to access roundTime later
    List<Map<String, dynamic>> insertedMatchesDetails = [];
    List<int> matchIds = [];

    try {
      // 1. Insert Sample Matches
      List<Map<String, dynamic>> sampleMatchesData = [
        // Match 0: 1 Round, 1 min round time
        {
          'matchName': 'Quick Spar (1 Round)',
          'matchDate': '2025-04-27',
          'rounds': 1,
          'finishedAtRound': 1, // Finished
          'totalTime': '01:00', // Approx
          'roundTime': 60, // 1 minute
          'breakTime': 10,
        },
        // Match 1: 3 Rounds, 1.5 min round time
        {
          'matchName': 'Standard Bout (3 Rounds)',
          'matchDate': '2025-04-27',
          'rounds': 3,
          'finishedAtRound': 3, // Finished
          'totalTime': '06:00', // Approx 3*1.5 + 2*0.5
          'roundTime': 90, // 1.5 minutes
          'breakTime': 30,
        },
        // Match 2: 2 Rounds, 30 sec round time (Very Short)
        {
          'matchName': 'Short Rounds (2 Rounds)',
          'matchDate': '2025-04-26',
          'rounds': 2,
          'finishedAtRound': 0, // Not finished yet
          'totalTime': '00:00',
          'roundTime': 30, // 30 seconds
          'breakTime': 10,
        },
         // Match 3: 5 Rounds, 3 min round time
        {
          'matchName': 'Endurance Test (5 Rounds)',
          'matchDate': '2025-04-25',
          'rounds': 5,
          'finishedAtRound': 5, // Finished
          'totalTime': '19:00', // Approx 5*3 + 4*1
          'roundTime': 180, // 3 minutes
          'breakTime': 60,
        },
        // Add more diverse matches if needed
         {
          'matchName': 'BlueBoxer vs RedBoxer',
          'matchDate': '2025-03-07',
          'rounds': 3,
          'finishedAtRound': 0,
          'totalTime': '00:00',
          'roundTime': 180, // 3 min
          'breakTime': 60,
        },
        {
          'matchName': 'Themis vs Nick',
          'matchDate': '2025-03-07',
          'rounds': 5,
          'finishedAtRound': 0,
          'totalTime': '00:00',
          'roundTime': 180, // 3 min
          'breakTime': 60,
        },
      ];

      for (var matchData in sampleMatchesData) {
        final id = await insertMatch(
          matchName: matchData['matchName'],
          rounds: matchData['rounds'],
          matchDate: matchData['matchDate'],
          roundTime: matchData['roundTime'],
          breakTime: matchData['breakTime'],
        );
        matchIds.add(id);
        // Store details including the ID and roundTime
        insertedMatchesDetails.add({...matchData, 'id': id});

        // Update finished matches immediately
        if (matchData['finishedAtRound'] > 0) {
          await updateEditMatch(
            id: id,
            matchName: matchData['matchName'],
            matchDate: matchData['matchDate'],
            rounds: matchData['rounds'],
            finishedAtRound: matchData['finishedAtRound'],
            totalTime: matchData['totalTime'],
            roundTime: matchData['roundTime'],
            breakTime: matchData['breakTime'],
          );
        }
      }
      debugPrint("Inserted ${matchIds.length} sample matches.");

      // 2. Insert Sample Events and Rounds (Simplified: One event per match for sample data)
      List<String> eventIds = [];
      List<Map<String, dynamic>> roundDetails = []; // Store {roundId, matchId, roundNumber, eventId}

      for (var matchDetail in insertedMatchesDetails) {
        int matchId = matchDetail['id'];
        int numRounds = matchDetail['rounds'];
        int finishedAt = matchDetail['finishedAtRound'];
        String? winner = (finishedAt > 0)
            ? (_random.nextBool() ? (_random.nextBool() ? 'BlueBoxer' : 'RedBoxer') : 'Draw')
            : null; // Assign winner randomly if finished

        String eventId = await insertEvent(matchId: matchId, winner: winner);
        eventIds.add(eventId);

        // Insert rounds up to the number specified in the match, or finishedAtRound if it's finished
        int roundsToInsert = (finishedAt > 0 && finishedAt <= numRounds) ? finishedAt : numRounds;
        // If not finished (finishedAt == 0), we might only insert *some* rounds if simulating an ongoing match
        // For simplicity here, if not finished, we'll insert rounds as if it's *about* to start or ongoing.
        // Let's insert rounds for matches that aren't marked as finished yet too.
        roundsToInsert = numRounds; // Insert all potential rounds for simplicity

        for (int r = 1; r <= roundsToInsert; r++) {
          int roundId = await insertRound(matchId: matchId, eventId: eventId, round: r);
          if (roundId > 0) {
            roundDetails.add({
              'roundId': roundId,
              'matchId': matchId,
              'roundNumber': r,
              'eventId': eventId
            });
          }
        }
      }
      debugPrint("Inserted ${eventIds.length} sample events.");
      debugPrint("Inserted ${roundDetails.length} sample rounds.");


      // 3. Insert Sample Messages using the new randomized helper
      int totalMessagesInserted = 0;
      for (var roundInfo in roundDetails) {
        int roundId = roundInfo['roundId'];
        int matchId = roundInfo['matchId'];

        // Find the corresponding match details to get roundTime
        final matchDetail = insertedMatchesDetails.firstWhere((m) => m['id'] == matchId);
        int roundTimeSeconds = matchDetail['roundTime'] as int;

        // Determine average punches based on round time (e.g., more punches for longer rounds)
        int avgPunches = (roundTimeSeconds / 60 * 15).round(); // Approx 15 punches per minute avg
        avgPunches = max(5, avgPunches); // Ensure at least a few punches even for short rounds

        debugPrint("Inserting messages for Match $matchId, Round ${roundInfo['roundNumber']} (ID: $roundId), Round Time: $roundTimeSeconds s, Avg Punches: $avgPunches");

        int messagesForThisRound = await _insertRandomizedMessagesForRound(
          db: db,
          roundId: roundId,
          matchId: matchId,
          roundTimeSeconds: roundTimeSeconds,
          avgPunchesPerBoxer: avgPunches ~/ 2, // Per boxer
        );
        totalMessagesInserted += messagesForThisRound;
         debugPrint(" -> Inserted $messagesForThisRound messages for Round $roundId.");
      }
      debugPrint("Inserted a total of $totalMessagesInserted sample messages across all rounds.");


      // 4. Insert Sample Training Data (Timestamp remains fully random HH:MM:SS)
      int trainingDataInserted = 0;
      for (int i = 0; i < 50; i++) {
        String device = _random.nextBool() ? 'BlueBoxer' : 'RedBoxer';
        String punchBy = device; // Simplification for training data
        // Keep timestamp fully random (00:00:00 to 23:59:59) for training data
        String timeString =
            "${_random.nextInt(24).toString().padLeft(2, '0')}:${_random.nextInt(60).toString().padLeft(2, '0')}:${_random.nextInt(60).toString().padLeft(2, '0')}";
        await insertTrainingData(
          device,
          punchBy,
          (i + 1).toString(), // Using loop index as dummy punch count
          timeString,
          (_random.nextInt(800) + 100).toString(), // Random sensor value
        );
        trainingDataInserted++;
      }
      debugPrint(
        "Inserted $trainingDataInserted sample training data records.",
      );

      debugPrint("Comprehensive sample data insertion COMPLETE.");

    } catch (e, stacktrace) {
      debugPrint("Error inserting sample data: $e");
      debugPrint("Stacktrace: $stacktrace");
      // Consider re-throwing or handling the error more robustly
    }
  }


  // --- METHOD SIGNATURES AND UTILITY METHODS --- (No changes needed below this line)

  // Messages
  Future<int> insertMessage( // Return int (the inserted row id) or void
    String device,
    String punchBy, // Changed from oppositeDevice for clarity
    String punchCount,
    String timestamp, // Should be HH:MM:SS format for round time
    String sensorValue,
    int roundId,
    int matchId,
  ) async {
    final db = await database;
    // Basic validation
    if (device.isEmpty || punchBy.isEmpty || roundId <= 0 || matchId <= 0) {
       debugPrint("Warning: Invalid data provided to insertMessage. Skipping insert.");
       return 0; // Indicate failure or skip
    }
    try {
       final id = await db.insert('messages', {
         'device': device,
         'punchBy': punchBy,
         'punchCount': punchCount,
         'timestamp': timestamp, // Store as text "HH:MM:SS"
         'sensorValue': sensorValue,
         'roundId': roundId,
         'matchId': matchId,
       });
       return id;
    } catch (e) {
       debugPrint("Error inserting message: $e");
       return 0; // Indicate failure
    }
  }

  Future<List<Map<String, dynamic>>> fetchMessages() async {
    final db = await database;
    return await db.query('messages', orderBy: 'id DESC');
  }

  Future<List<Map<String, dynamic>>> fetchMessagesByMatchId(int matchId) async {
    final db = await database;
    return await db.query(
      'messages',
      where: 'matchId = ?',
      whereArgs: [matchId],
      orderBy: 'id ASC', // Often useful to see messages in order
    );
  }

  Future<List<Map<String, dynamic>>> fetchMessagesByRoundId(int roundId) async {
    final db = await database;
    // For now, sort by ID which approximates chronological order if inserted correctly
    return await db.query(
      'messages',
      where: 'roundId = ?',
      whereArgs: [roundId],
      orderBy: 'id ASC', // Order by insertion sequence
    );
  }

   /// Fetches messages for a specific round, ordered chronologically by timestamp.
   /// Note: This requires parsing the 'timestamp' string, which can be inefficient.
   /// Consider storing timestamp as INTEGER seconds within the round if performance is critical.
   Future<List<Map<String, dynamic>>> fetchMessagesByRoundIdOrdered(int roundId) async {
     final db = await database;
     final messages = await db.query(
       'messages',
       where: 'roundId = ?',
       whereArgs: [roundId],
       // No DB-level order by HH:MM:SS string easily, so fetch all and sort in Dart
     );

     // Helper to parse HH:MM:SS to seconds
     int parseTimeStringToSeconds(String timeString) {
       try {
         final parts = timeString.split(':');
         if (parts.length == 3) {
           int h = int.parse(parts[0]);
           int m = int.parse(parts[1]);
           int s = int.parse(parts[2]);
           return h * 3600 + m * 60 + s;
         }
       } catch (e) {
         debugPrint("Error parsing time string '$timeString': $e");
       }
       return 0; // Default or error case
     }

     // Sort the results in Dart
     messages.sort((a, b) {
       final timeA = parseTimeStringToSeconds(a['timestamp'] as String? ?? '00:00:00');
       final timeB = parseTimeStringToSeconds(b['timestamp'] as String? ?? '00:00:00');
       return timeA.compareTo(timeB);
     });

     return messages;
   }


  Future<void> clearMessages() async {
    final db = await database;
    await db.delete('messages');
    debugPrint("Cleared messages table.");
  }

  // Training Data
  Future<void> insertTrainingData(
    String device,
    String punchBy,
    String punchCount,
    String timestamp, // HH:MM:SS format
    String sensorValue,
    // int? roundId, // Optional: Link training data to a round if applicable
  ) async {
    final db = await database;
    await db.insert('trainingdata', {
      'device': device,
      'punchBy': punchBy,
      'punchCount': punchCount,
      'timestamp': timestamp, // Store as text "HH:MM:SS"
      'sensorValue': sensorValue,
      // 'roundId': roundId,
    });
  }

  Future<List<Map<String, dynamic>>> fetchTrainingData() async {
    final db = await database;
    return await db.query('trainingdata', orderBy: 'id DESC');
  }

  Future<void> clearTrainingData() async {
    final db = await database;
    await db.delete('trainingdata');
    debugPrint("Cleared trainingdata table.");
  }

  // Settings
  Future<void> upsertSettings({
    required int fsrSensitivity,
    required int fsrThreshold,
    required int rounds,
    required int roundTime, // in seconds
    required int breakTime, // in seconds
    required int secondsBeforeRoundBegins,
  }) async {
    final db = await database;
    await db.insert('settings', {
      'id': 1, // Always use ID 1 for the single settings row
      'fsrSensitivity': fsrSensitivity,
      'fsrThreshold': fsrThreshold,
      'rounds': rounds,
      'roundTime': roundTime,
      'breakTime': breakTime,
      'secondsBeforeRoundBegins': secondsBeforeRoundBegins,
    }, conflictAlgorithm: ConflictAlgorithm.replace); // Replace existing settings
    debugPrint("Settings upserted.");
  }

  Future<Map<String, dynamic>?> fetchSettings() async {
    final db = await database;
    final List<Map<String, dynamic>> settings = await db.query(
      'settings',
      where: 'id = ?',
      whereArgs: [1], // Fetch the settings row with ID 1
      limit: 1,
    );
    if (settings.isNotEmpty) {
      return settings.first;
    } else {
      debugPrint("Warning: Settings not found, returning null. Consider inserting defaults.");
      // Optionally insert defaults here if they are missing
      // await _insertDefaultSettings(db);
      // final List<Map<String, dynamic>> defaultSettings = await db.query('settings', where: 'id = ?', whereArgs: [1], limit: 1);
      // return defaultSettings.isNotEmpty ? defaultSettings.first : null;
      return null;
    }
  }

  Future<void> clearSettings() async {
    final db = await database;
    // Instead of deleting, just reset to defaults
    await _insertDefaultSettings(db);
    debugPrint("Settings reset to default.");
  }

  // Matches
  Future<int> insertMatch({
    required String matchName,
    required int rounds,
    required String matchDate, // Consider storing as ISO8601 string or INTEGER timestamp
    required int roundTime, // in seconds
    required int breakTime, // in seconds
  }) async {
    final db = await database;
    final Map<String, dynamic> matchData = {
      'matchName': matchName,
      'rounds': rounds,
      'matchDate': matchDate, // Store as provided string
      'roundTime': roundTime,
      'breakTime': breakTime,
      'finishedAtRound': 0, // Default: Not finished
      'totalTime': '00:00:00', // Default: No time elapsed yet
    };
    final id = await db.insert('matches', matchData);
    debugPrint("Inserted match '$matchName' with ID: $id");
    return id;
  }

  Future<void> updateEditMatch({
    required int id,
    required String matchName,
    required String matchDate,
    required int rounds,
    required int finishedAtRound, // The round number it finished *after* (0 if not finished)
    required String totalTime, // Total duration HH:MM:SS
    required int roundTime,
    required int breakTime,
  }) async {
    final db = await database;
    int count = await db.update(
      'matches',
      {
        'matchName': matchName,
        'matchDate': matchDate,
        'rounds': rounds,
        'finishedAtRound': finishedAtRound,
        'totalTime': totalTime, // Store as HH:MM:SS string
        'roundTime': roundTime,
        'breakTime': breakTime,
      },
      where: 'id = ?',
      whereArgs: [id],
    );
     if (count > 0) {
        debugPrint("Updated match with ID: $id");
     } else {
        debugPrint("Warning: Match with ID $id not found for update.");
     }
  }

  Future<List<Map<String, dynamic>>> fetchMatches() async {
    final db = await database;
    // Order by date descending (most recent first), then by ID as fallback
    return await db.query('matches', orderBy: 'matchDate DESC, id DESC');
  }

  Future<void> deleteMatch(int id) async {
    final db = await database;
    // Foreign key constraints with ON DELETE CASCADE should handle related data
    int count = await db.delete('matches', where: 'id = ?', whereArgs: [id]);
    if (count > 0) {
      debugPrint("Deleted match with ID: $id and related data (via CASCADE).");
    } else {
      debugPrint("Match with ID: $id not found for deletion.");
    }
  }

  Future<Map<String, dynamic>?> fetchMatchById(int id) async {
    final db = await database;
    final result = await db.query(
      'matches',
      where: 'id = ?',
      whereArgs: [id],
      limit: 1,
    );
    return result.isNotEmpty ? result.first : null;
  }

  Future<void> clearMatches() async {
    final db = await database;
    // This will cascade delete related events, rounds, and messages
    await db.delete('matches');
    debugPrint("Cleared matches table and related data (via CASCADE).");
  }

  // Events
  Future<String> insertEvent({required int matchId, String? winner}) async {
    final db = await database;
    String eventId = _uuid.v4(); // Generate a unique ID for the event
    await db.insert('events', {
      'id': eventId,
      'timestamp': DateTime.now().millisecondsSinceEpoch, // Record event creation time
      'matchId': matchId,
      'winner': winner, // Can be null if match is ongoing or a draw
    });
    debugPrint("Inserted event $eventId for Match ID $matchId");
    return eventId;
  }

  Future<List<Map<String, dynamic>>> fetchEvents() async {
    final db = await database;
    return await db.query('events', orderBy: 'timestamp DESC'); // Most recent events first
  }

  Future<List<Map<String, dynamic>>> fetchEventsByMatchId(int matchId) async {
    final db = await database;
    return await db.query(
      'events',
      where: 'matchId = ?',
      whereArgs: [matchId],
      orderBy: 'timestamp DESC', // Usually only one event per match in current design
    );
  }

  Future<void> clearEvents() async {
    final db = await database;
    // This will cascade delete related rounds and messages
    await db.delete('events');
    debugPrint("Cleared events table and related data (via CASCADE).");
  }

  Future<void> updateCurrentEventWinner(String eventId, String? winner) async {
    final db = await database;
    int count = await db.update(
      'events',
      {'winner': winner}, // Update only the winner field
      where: 'id = ?',
      whereArgs: [eventId],
    );
     if (count > 0) {
       debugPrint("Updated winner for event $eventId to '$winner'");
     } else {
       debugPrint("Warning: Event with ID $eventId not found for winner update.");
     }
  }

  // Rounds
  Future<int> insertRound({
    required int matchId,
    required int round, // The round number (1, 2, 3...)
    required String? eventId, // Associated event
  }) async {
    final db = await database;
    final roundData = {
      'matchId': matchId,
      'round': round,
      'eventId': eventId,
      'timestamp': DateTime.now().millisecondsSinceEpoch, // Record round creation time
      // 'punchCount': 0, // Initial punch count - might be better calculated dynamically
    };
    int id = 0;
    try {
      // Use insert with conflictAlgorithm ignore or retrieve existing if needed
      id = await db.insert(
          'rounds',
          roundData,
          conflictAlgorithm: ConflictAlgorithm.ignore); // Ignore if UNIQUE constraint fails
      if (id > 0) {
         debugPrint("Inserted round $round for Event $eventId, Round ID: $id");
      } else {
         // If ID is 0, it means the round likely already existed due to UNIQUE constraint
         debugPrint("Round $round for Event $eventId likely already exists (or other insert error).");
         // Optionally, query to get the existing ID if needed
         final existing = await db.query('rounds', where: 'eventId = ? AND round = ?', whereArgs: [eventId, round], limit: 1);
         if (existing.isNotEmpty) {
           id = existing.first['id'] as int;
           debugPrint("Found existing Round ID: $id");
         }
      }
    } on DatabaseException catch (e) {
      // Catch specific errors if needed, though ConflictAlgorithm.ignore handles UNIQUE
      debugPrint("Database error inserting round: $e");
      // Rethrow or handle as appropriate
    }
    return id; // Return the new ID or the existing ID if found, or 0 on error
  }


  Future<List<Map<String, dynamic>>> fetchRounds() async {
    final db = await database;
    // Fetch rounds, potentially joining with events/matches if needed later
    List<Map<String, dynamic>> rounds = await db.query(
      'rounds',
      orderBy: 'matchId ASC, round ASC', // Order logically
    );
    // Add human-readable timestamp (consider doing this formatting in the UI layer)
    return rounds.map((round) {
      final timestamp = round['timestamp'];
      String humanReadableTimestamp = "N/A";
      if (timestamp != null && timestamp is int) {
        try {
          var date = DateTime.fromMillisecondsSinceEpoch(timestamp);
          humanReadableTimestamp =
              "${date.year}-${date.month.toString().padLeft(2, '0')}-${date.day.toString().padLeft(2, '0')} ${date.hour.toString().padLeft(2, '0')}:${date.minute.toString().padLeft(2, '0')}:${date.second.toString().padLeft(2, '0')}";
        } catch (e) {
          debugPrint("Error formatting timestamp $timestamp: $e");
        }
      }
      // Create a mutable copy to add the formatted timestamp
      var mutableRound = Map<String, dynamic>.from(round);
      mutableRound['humanReadableTimestamp'] = humanReadableTimestamp;
      return mutableRound;
    }).toList();
  }

   Future<List<Map<String, dynamic>>> fetchRoundsByEventId(String eventId) async {
     final db = await database;
     return await db.query(
       'rounds',
       where: 'eventId = ?',
       whereArgs: [eventId],
       orderBy: 'round ASC', // Order by round number
     );
   }

  Future<void> clearRounds() async {
    final db = await database;
    // This will cascade delete related messages
    await db.delete('rounds');
    debugPrint("Cleared rounds table and related data (via CASCADE).");
  }

  // Utilities

  /// Calculates punch counts for an entire event by summing counts from its rounds.
  Future<Map<String, int>> getEventPunchCounts(String eventId) async {
    final db = await database;
    // Find all round IDs associated with the event
    final eventRounds = await db.query(
      'rounds',
      columns: ['id'], // Only need the round IDs
      where: 'eventId = ?',
      whereArgs: [eventId],
    );

    if (eventRounds.isEmpty) {
      return {'BlueBoxer': 0, 'RedBoxer': 0}; // No rounds for this event
    }

    final roundIds = eventRounds.map((r) => r['id'] as int).toList();

    // Query messages belonging to any of these rounds
    // Use COUNT(*) and GROUP BY for efficiency
    final results = await db.query(
      'messages',
      columns: ['punchBy', 'COUNT(*) as count'],
      where: 'roundId IN (${List.filled(roundIds.length, '?').join(',')})',
      whereArgs: roundIds,
      groupBy: 'punchBy',
    );

    int blue = 0;
    int red = 0;
    for (final row in results) {
      final who = row['punchBy'] as String?;
      final count = row['count'] as int? ?? 0;
      if (who == 'BlueBoxer') {
        blue = count;
      } else if (who == 'RedBoxer') {
        red = count;
      }
    }
    return {'BlueBoxer': blue, 'RedBoxer': red};
  }

  /// Calculates punch counts for a specific round.
  Future<Map<String, int>> getRoundPunchCounts(int roundId) async {
    final db = await database;
    // Use COUNT(*) and GROUP BY for efficiency
    final results = await db.query(
      'messages',
      columns: ['punchBy', 'COUNT(*) as count'],
      where: 'roundId = ?',
      whereArgs: [roundId],
      groupBy: 'punchBy',
    );

    int blue = 0;
    int red = 0;
    for (final row in results) {
      final who = row['punchBy'] as String?;
      final count = row['count'] as int? ?? 0;
      if (who == 'BlueBoxer') {
        blue = count;
      } else if (who == 'RedBoxer') {
        red = count;
      }
    }
    return {'BlueBoxer': blue, 'RedBoxer': red};
  }


} // End of DatabaseHelper class

















import 'dart:math'; // Needed for random sample data
import 'package:flutter/material.dart'; // Needed for debugPrint
import 'package:sqflite/sqflite.dart';
import 'package:path/path.dart';
import 'package:path_provider/path_provider.dart';
import 'package:uuid/uuid.dart'; // Import the uuid package

// Helper function to check if a column exists (remains the same)
Future<bool> _columnExists(Database db, String table, String columnName) async {
  final columns = await db.rawQuery('PRAGMA table_info($table)');
  for (final col in columns) {
    if (col['name'] == columnName) {
      return true;
    }
  }
  return false;
}

class DatabaseHelper {
  // Singleton instance
  static final DatabaseHelper _instance = DatabaseHelper._internal();
  static Database? _database;
  final Uuid _uuid = const Uuid(); // Instantiate Uuid generator
  final Random _random = Random(); // Instantiate Random generator

  // Private constructor
  DatabaseHelper._internal();

  // Factory constructor to return the same instance
  factory DatabaseHelper() => _instance;

  // Getter to access the database
  Future<Database> get database async {
    if (_database != null) return _database!;
    _database = await _initDatabase();
    return _database!;
  }

  // --- Database Initialization and Schema ---
  // _initDatabase, _onCreate, table creation helpers, _insertDefaultSettings, _onUpgrade
  // ... (These methods remain the same as the previous version) ...
  Future<Database> _initDatabase() async {
    final directory = await getApplicationDocumentsDirectory();
    final path = join(directory.path, 'messages.db');
    return await openDatabase(
      path,
      version: 7,
      onOpen: (db) async {
        await db.execute("PRAGMA foreign_keys = ON");
      },
      onCreate: _onCreate,
      onUpgrade: _onUpgrade,
    );
  }

  Future<void> _onCreate(Database db, int version) async {
    await db.execute("PRAGMA foreign_keys = ON");
    debugPrint("Running _onCreate for database version $version");
    await _createMatchesTable(db);
    await _createEventsTable(db);
    await _createRoundsTable(db);
    await _createMessagesTable(db);
    await _createTrainingDataTable(db);
    await _createSettingsTable(db);
    await _insertDefaultSettings(db);
    debugPrint("_onCreate complete.");
  }

  Future<void> _createMatchesTable(Database db) async {
    await db.execute(
      ''' CREATE TABLE matches( id INTEGER PRIMARY KEY AUTOINCREMENT, matchName TEXT, matchDate TEXT, rounds INTEGER, finishedAtRound INTEGER, totalTime TEXT, roundTime INTEGER, breakTime INTEGER ) ''',
    );
    debugPrint("Table 'matches' created.");
  }

  Future<void> _createEventsTable(Database db) async {
    await db.execute(
      ''' CREATE TABLE events( id TEXT PRIMARY KEY, timestamp INTEGER, matchId INTEGER, winner TEXT, FOREIGN KEY (matchId) REFERENCES matches(id) ON DELETE CASCADE ) ''',
    );
    debugPrint("Table 'events' created.");
  }

  Future<void> _createRoundsTable(Database db) async {
    await db.execute(
      ''' CREATE TABLE rounds( id INTEGER PRIMARY KEY AUTOINCREMENT, eventId TEXT, punchCount INTEGER, matchId INTEGER, round INTEGER, timestamp INTEGER, FOREIGN KEY (matchId) REFERENCES matches(id) ON DELETE CASCADE, FOREIGN KEY (eventId) REFERENCES events(id) ON DELETE CASCADE, UNIQUE(eventId, round) ) ''',
    );
    debugPrint("Table 'rounds' created.");
  }

  Future<void> _createMessagesTable(Database db) async {
    await db.execute(
      ''' CREATE TABLE messages( id INTEGER PRIMARY KEY AUTOINCREMENT, device TEXT, punchBy TEXT, punchCount TEXT, timestamp TEXT, sensorValue TEXT, roundId INTEGER, matchId INTEGER, FOREIGN KEY (roundId) REFERENCES rounds(id) ON DELETE CASCADE, FOREIGN KEY (matchId) REFERENCES matches(id) ON DELETE CASCADE ) ''',
    );
    debugPrint("Table 'messages' created.");
  }

  Future<void> _createTrainingDataTable(Database db) async {
    await db.execute(
      ''' CREATE TABLE trainingdata( id INTEGER PRIMARY KEY AUTOINCREMENT, device TEXT, punchBy TEXT, punchCount TEXT, timestamp TEXT, sensorValue TEXT, roundId INTEGER ) ''',
    );
    debugPrint("Table 'trainingdata' created.");
  }

  Future<void> _createSettingsTable(Database db) async {
    await db.execute(
      ''' CREATE TABLE settings( id INTEGER PRIMARY KEY, fsrSensitivity INTEGER, fsrThreshold INTEGER, roundTime INTEGER, breakTime INTEGER, secondsBeforeRoundBegins INTEGER, rounds INTEGER ) ''',
    );
    debugPrint("Table 'settings' created.");
  }

  Future<void> _insertDefaultSettings(Database db) async {
    await db.insert('settings', {
      'id': 1,
      'fsrSensitivity': 800,
      'fsrThreshold': 200,
      'roundTime': 180,
      'breakTime': 60,
      'secondsBeforeRoundBegins': 5,
      'rounds': 3,
    }, conflictAlgorithm: ConflictAlgorithm.replace);
    debugPrint("Default settings inserted/replaced.");
  }

  Future<void> _onUpgrade(Database db, int oldVersion, int newVersion) async {
    debugPrint("Upgrading database from version $oldVersion to $newVersion");
    if (oldVersion < 4) {
      if (!await _columnExists(db, 'messages', 'device')) {
        await db.execute('ALTER TABLE messages ADD COLUMN device TEXT');
        debugPrint("Added 'device' column to messages table.");
      }
    }
    if (oldVersion < 5) {
      if (!await _columnExists(db, 'settings', 'fsrThreshold')) {
        await db.execute(
          'ALTER TABLE settings ADD COLUMN fsrThreshold INTEGER DEFAULT 200',
        );
        debugPrint("Added 'fsrThreshold' column to settings table.");
      }
      if (!await _columnExists(db, 'settings', 'roundTime')) {
        await db.execute(
          'ALTER TABLE settings ADD COLUMN roundTime INTEGER DEFAULT 180',
        );
        debugPrint("Added 'roundTime' column to settings table.");
      }
      if (!await _columnExists(db, 'settings', 'breakTime')) {
        await db.execute(
          'ALTER TABLE settings ADD COLUMN breakTime INTEGER DEFAULT 60',
        );
        debugPrint("Added 'breakTime' column to settings table.");
      }
      if (!await _columnExists(db, 'settings', 'secondsBeforeRoundBegins')) {
        await db.execute(
          'ALTER TABLE settings ADD COLUMN secondsBeforeRoundBegins INTEGER DEFAULT 5',
        );
        debugPrint(
          "Added 'secondsBeforeRoundBegins' column to settings table.",
        );
      }
    }
    if (oldVersion < 6) {
      if (!await _columnExists(db, 'messages', 'punchBy')) {
        await db.execute('ALTER TABLE messages ADD COLUMN punchBy TEXT');
        debugPrint("Added 'punchBy' column to messages table.");
      }
    }
    if (oldVersion < 7) {
      if (!await _columnExists(db, 'settings', 'rounds')) {
        await db.execute(
          'ALTER TABLE settings ADD COLUMN rounds INTEGER DEFAULT 3',
        );
        debugPrint("Added 'rounds' column to settings table.");
      }
    }
    debugPrint("Database upgrade complete.");
  }

  // --- Sample Data Insertion ---

  /// Clears all data from relevant tables. Call before inserting sample data.
  Future<void> _clearAllData() async {
    final db = await database;
    debugPrint("Clearing existing data...");
    await db.delete('messages');
    await db.delete('trainingdata');
    await db.delete('rounds');
    await db.delete('events');
    await db.delete('matches');
    debugPrint("Data cleared.");
  }

  /// **NEW HELPER:** Formats total seconds into HH:MM:SS string.
  String _formatSecondsToTimeString(int totalSeconds) {
    if (totalSeconds < 0) totalSeconds = 0; // Ensure non-negative
    int s = totalSeconds % 60;
    int m = (totalSeconds ~/ 60) % 60;
    int h = totalSeconds ~/ 3600;
    return "${h.toString().padLeft(2, '0')}:${m.toString().padLeft(2, '0')}:${s.toString().padLeft(2, '0')}";
  }

  /// Inserts a comprehensive set of sample data for testing.
  Future<void> insertComprehensiveSampleData() async {
    final db = await database;
    await _clearAllData();
    await _insertDefaultSettings(db);

    debugPrint("Inserting comprehensive sample data...");

    int round1_1 = 0, round2_1 = 0, round2_2 = 0, round2_3 = 0;
    int round3_1 = 0, round3_2 = 0, round3_3 = 0, round3_4 = 0, round3_5 = 0;
    int shortR1 = 0, shortR2 = 0;
    List<int> allInsertedRoundIds = [];

    try {
      // 1. Insert Sample Matches (Store data locally to access roundTime later)
      List<Map<String, dynamic>> sampleMatchesData = [
        {
        'matchName': '1 Round Practice Match',
        'matchDate': '2025-03-20',
        'rounds': 1,
        'finishedAtRound': 0,
        'totalTime': '00:00',
        'roundTime': 1,
        'breakTime': 10,
      },
      {
        'matchName': '2 Rounds Practice Match',
        'matchDate': '2024-11-20',
        'rounds': 2,
        'finishedAtRound': 0,
        'totalTime': '00:00',
        'roundTime': 1,
        'breakTime': 10,
      },
      {
        'matchName': '5 Rounds Practice Match',
        'matchDate': '2024-11-20',
        'rounds': 5,
        'finishedAtRound': 0,
        'totalTime': '00:00',
        'roundTime': 3,
        'breakTime': 120,
      },
      {
        'matchName': 'Test Quick Match',
        'matchDate': '2025-03-07',
        'rounds': 2,
        'finishedAtRound': 0,
        'totalTime': '00:00',
        'roundTime': 1,
        'breakTime': 10,
      },
      {
        'matchName': 'Championship Match',
        'matchDate': '2024-11-28',
        'rounds': 12,
        'finishedAtRound': 0,
        'totalTime': '00:00',
        'roundTime': 3,
        'breakTime': 120,
      },
      {
        'matchName': 'BlueBoxer vs RedBoxer',
        'matchDate': '2025-03-07',
        'rounds': 3,
        'finishedAtRound': 0,
        'totalTime': '00:00',
        'roundTime': 3,
        'breakTime': 120,
      },
      {
        'matchName': 'Themis vs Nick',
        'matchDate': '2025-03-07',
        'rounds': 5,
        'finishedAtRound': 0,
        'totalTime': '00:00',
        'roundTime': 3,
        'breakTime': 120,
      },
      {
        'matchName': 'Themis vs Panos',
        'matchDate': '2024-11-25',
        'rounds': 7,
        'finishedAtRound': 0,
        'totalTime': '00:00',
        'roundTime': 3,
        'breakTime': 120,
      },
        {
          'matchName': 'Quick Spar (1 Round)',
          'matchDate': '2025-04-27',
          'rounds': 1,
          'finishedAtRound': 1,
          'totalTime': '03:15',
          'roundTime': 1,
          'breakTime': 10,
        },
        {
          'matchName': 'Standard Bout (3 Rounds)',
          'matchDate': '2025-04-27',
          'rounds': 3,
          'finishedAtRound': 3,
          'totalTime': '11:00',
          'roundTime': 1,
          'breakTime': 10,
        },
        {
          'matchName': 'Short Rounds (2 Rounds)',
          'matchDate': '2025-04-26',
          'rounds': 2,
          'finishedAtRound': 0,
          'totalTime': '00:00',
          'roundTime': 1,
          'breakTime': 10,
        },
        {
          'matchName': 'Endurance Test (5 Rounds)',
          'matchDate': '2025-04-25',
          'rounds': 5,
          'finishedAtRound': 5,
          'totalTime': '19:00',
          'roundTime': 1,
          'breakTime': 10,
        },

        {
          'matchName': '' /* ... other matches ... */,
        }, // Add more sample matches as needed
      ];
      List<int> matchIds = [];
      List<Map<String, dynamic>> insertedMatchesDetails =
          []; // Store details with ID

      for (var matchData in sampleMatchesData) {
        final id = await insertMatch(
          /* ... details ... */
          matchName: matchData['matchName'],
          rounds: matchData['rounds'],
          matchDate: matchData['matchDate'],
          roundTime: matchData['roundTime'],
          breakTime: matchData['breakTime'],
        );
        matchIds.add(id);
        insertedMatchesDetails.add({...matchData, 'id': id});
        if (matchData['finishedAtRound'] > 0) {
          await updateEditMatch(
            id: id,
            /* ... rest ... */
            matchName: matchData['matchName'],
            matchDate: matchData['matchDate'],
            rounds: matchData['rounds'],
            finishedAtRound: matchData['finishedAtRound'],
            totalTime: matchData['totalTime'],
            roundTime: matchData['roundTime'],
            breakTime: matchData['breakTime'],
          );
        }
      }
      debugPrint("Inserted ${matchIds.length} sample matches.");

      // 2. Insert Sample Events
      List<String> eventIds = [];
      if (matchIds.length >= 4) {
        String event1Id = await insertEvent(
          matchId: matchIds[0],
          winner: 'BlueBoxer',
        );
        eventIds.add(event1Id);
        String event2Id = await insertEvent(
          matchId: matchIds[1],
          winner: 'RedBoxer',
        );
        eventIds.add(event2Id);
        String eventShortround = await insertEvent(
          matchId: matchIds[2],
          winner: null,
        );
        eventIds.add(eventShortround);
        String event3Id = await insertEvent(
          matchId: matchIds[3],
          winner: 'Draw',
        );
        eventIds.add(event3Id);
        debugPrint("Inserted ${eventIds.length} sample events.");
      } else {
        /* Warning */
      }

      // 3. Insert Sample Rounds
      if (eventIds.length >= 4 && matchIds.length >= 4) {
        round1_1 = await insertRound(
          matchId: matchIds[0],
          eventId: eventIds[0],
          round: 1,
        );
        if (round1_1 > 0) allInsertedRoundIds.add(round1_1);
        round2_1 = await insertRound(
          matchId: matchIds[1],
          eventId: eventIds[1],
          round: 1,
        );
        if (round2_1 > 0) allInsertedRoundIds.add(round2_1);
        round2_2 = await insertRound(
          matchId: matchIds[1],
          eventId: eventIds[1],
          round: 2,
        );
        if (round2_2 > 0) allInsertedRoundIds.add(round2_2);
        round2_3 = await insertRound(
          matchId: matchIds[1],
          eventId: eventIds[1],
          round: 3,
        );
        if (round2_3 > 0) allInsertedRoundIds.add(round2_3);
        shortR1 = await insertRound(
          matchId: matchIds[2],
          eventId: eventIds[2],
          round: 1,
        );
        if (shortR1 > 0) allInsertedRoundIds.add(shortR1);
        shortR2 = await insertRound(
          matchId: matchIds[2],
          eventId: eventIds[2],
          round: 2,
        );
        if (shortR2 > 0) allInsertedRoundIds.add(shortR2);
        round3_1 = await insertRound(
          matchId: matchIds[3],
          eventId: eventIds[3],
          round: 1,
        );
        if (round3_1 > 0) allInsertedRoundIds.add(round3_1);
        round3_2 = await insertRound(
          matchId: matchIds[3],
          eventId: eventIds[3],
          round: 2,
        );
        if (round3_2 > 0) allInsertedRoundIds.add(round3_2);
        round3_3 = await insertRound(
          matchId: matchIds[3],
          eventId: eventIds[3],
          round: 3,
        );
        if (round3_3 > 0) allInsertedRoundIds.add(round3_3);
        round3_4 = await insertRound(
          matchId: matchIds[3],
          eventId: eventIds[3],
          round: 4,
        );
        if (round3_4 > 0) allInsertedRoundIds.add(round3_4);
        round3_5 = await insertRound(
          matchId: matchIds[3],
          eventId: eventIds[3],
          round: 5,
        );
        if (round3_5 > 0) allInsertedRoundIds.add(round3_5);
      } else {
        /* Warning */
      }
      debugPrint("Inserted ${allInsertedRoundIds.length} sample rounds.");

      // 4. Insert Sample Messages for some Rounds
      int messagesInserted = 0;

      // ---> Messages for Round 1 of Match 0 (roundTime = 180s) <---
      if (round1_1 > 0 && insertedMatchesDetails.isNotEmpty) {
        final matchDetails = insertedMatchesDetails.firstWhere(
          (m) => m['id'] == matchIds[0],
        );
        int roundTimeSeconds = matchDetails['roundTime'] as int;
        int currentSecondsInRound = 0; // Start time for this round
        debugPrint(
          "Inserting messages for round1_1 (Match 0), Round Time: $roundTimeSeconds seconds",
        );

        // Loop for BlueBoxer punches
        int bluePunchCount = 15 + _random.nextInt(10);
        for (int i = 1; i <= bluePunchCount; i++) {
          int increment = 1 + _random.nextInt(5); // Advance time by 1-5 seconds
          currentSecondsInRound += increment;
          if (currentSecondsInRound >= roundTimeSeconds) {
            break; // Stop if round time exceeded
          }

          String timeString = _formatSecondsToTimeString(
            currentSecondsInRound,
          ); // <<< Use Helper
          await insertMessage(
            'BlueBoxer',
            'RedBoxer',
            i.toString(),
            timeString,
            (_random.nextInt(500) + 300).toString(),
            round1_1,
            matchIds[0],
          );
          messagesInserted++;
        }

        // Loop for RedBoxer punches (reset time or continue?) Let's interleave roughly - use same counter
        int redPunchCount = 10 + _random.nextInt(8);
        for (int i = 1; i <= redPunchCount; i++) {
          int increment =
              1 + _random.nextInt(6); // Advance time slightly differently
          currentSecondsInRound += increment;
          if (currentSecondsInRound >= roundTimeSeconds) {
            break; // Stop if round time exceeded
          }

          String timeString = _formatSecondsToTimeString(
            currentSecondsInRound,
          ); // <<< Use Helper
          await insertMessage(
            'RedBoxer',
            'BlueBoxer',
            i.toString(),
            timeString,
            (_random.nextInt(400) + 250).toString(),
            round1_1,
            matchIds[0],
          );
          messagesInserted++;
        }
      }

      // ---> Messages for Round 2 of Match 1 (roundTime = 180s) <---
      if (round2_2 > 0 && insertedMatchesDetails.length >= 2) {
        final matchDetails = insertedMatchesDetails.firstWhere(
          (m) => m['id'] == matchIds[1],
        );
        int roundTimeSeconds = matchDetails['roundTime'] as int;
        int currentSecondsInRound = 0; // Start time for this round
        debugPrint(
          "Inserting messages for round2_2 (Match 1), Round Time: $roundTimeSeconds seconds",
        );

        int bluePunchCount = 20 + _random.nextInt(15);
        for (int i = 1; i <= bluePunchCount; i++) {
          int increment = 1 + _random.nextInt(4);
          currentSecondsInRound += increment;
          if (currentSecondsInRound >= roundTimeSeconds) break;
          String timeString = _formatSecondsToTimeString(
            currentSecondsInRound,
          ); // <<< Use Helper
          await insertMessage(
            'BlueBoxer',
            'RedBoxer',
            i.toString(),
            timeString,
            (_random.nextInt(600) + 350).toString(),
            round2_2,
            matchIds[1],
          );
          messagesInserted++;
        }

        int redPunchCount = 25 + _random.nextInt(10);
        for (int i = 1; i <= redPunchCount; i++) {
          int increment = 1 + _random.nextInt(5);
          currentSecondsInRound += increment;
          if (currentSecondsInRound >= roundTimeSeconds) break;
          String timeString = _formatSecondsToTimeString(
            currentSecondsInRound,
          ); // <<< Use Helper
          await insertMessage(
            'RedBoxer',
            'BlueBoxer',
            i.toString(),
            timeString,
            (_random.nextInt(550) + 400).toString(),
            round2_2,
            matchIds[1],
          );
          messagesInserted++;
        }
      }

      // ---> Messages for Round 1 of Short Round Match (Match 2, roundTime = 60s) <---
      if (shortR1 > 0 && insertedMatchesDetails.length >= 3) {
        final matchDetails = insertedMatchesDetails.firstWhere(
          (m) => m['id'] == matchIds[2],
        );
        int roundTimeSeconds = matchDetails['roundTime'] as int; // Should be 60
        int currentSecondsInRound = 0; // Start time for this round
        debugPrint(
          "Inserting messages for shortR1 (Match 2), Round Time: $roundTimeSeconds seconds",
        );

        int bluePunchCount = 8 + _random.nextInt(7);
        for (int i = 1; i <= bluePunchCount; i++) {
          int increment = 1 + _random.nextInt(3); // Smaller increments
          currentSecondsInRound += increment;
          if (currentSecondsInRound >= roundTimeSeconds) break;
          String timeString = _formatSecondsToTimeString(
            currentSecondsInRound,
          ); // <<< Use Helper
          await insertMessage(
            'BlueBoxer',
            'RedBoxer',
            i.toString(),
            timeString,
            (_random.nextInt(400) + 200).toString(),
            shortR1,
            matchIds[2],
          );
          messagesInserted++;
        }

        int redPunchCount = 7 + _random.nextInt(8);
        for (int i = 1; i <= redPunchCount; i++) {
          int increment = 1 + _random.nextInt(4);
          currentSecondsInRound += increment;
          if (currentSecondsInRound >= roundTimeSeconds) break;
          String timeString = _formatSecondsToTimeString(
            currentSecondsInRound,
          ); // <<< Use Helper
          await insertMessage(
            'RedBoxer',
            'BlueBoxer',
            i.toString(),
            timeString,
            (_random.nextInt(350) + 250).toString(),
            shortR1,
            matchIds[2],
          );
          messagesInserted++;
        }
      }

      // ---> Messages for Round 3 of Match 3 (Endurance Test, roundTime = 180s) <---
      if (round3_3 > 0 && insertedMatchesDetails.length >= 4) {
        final matchDetails = insertedMatchesDetails.firstWhere(
          (m) => m['id'] == matchIds[3],
        );
        int roundTimeSeconds = matchDetails['roundTime'] as int;
        int currentSecondsInRound = 0; // Start time for this round
        debugPrint(
          "Inserting messages for round3_3 (Match 3), Round Time: $roundTimeSeconds seconds",
        );

        int bluePunchCount = 18 + _random.nextInt(12);
        for (int i = 1; i <= bluePunchCount; i++) {
          int increment = 1 + _random.nextInt(5);
          currentSecondsInRound += increment;
          if (currentSecondsInRound >= roundTimeSeconds) break;
          String timeString = _formatSecondsToTimeString(
            currentSecondsInRound,
          ); // <<< Use Helper
          await insertMessage(
            'BlueBoxer',
            'RedBoxer',
            i.toString(),
            timeString,
            (_random.nextInt(500) + 320).toString(),
            round3_3,
            matchIds[3],
          );
          messagesInserted++;
        }

        int redPunchCount = 16 + _random.nextInt(10);
        for (int i = 1; i <= redPunchCount; i++) {
          int increment = 1 + _random.nextInt(6);
          currentSecondsInRound += increment;
          if (currentSecondsInRound >= roundTimeSeconds) break;
          String timeString = _formatSecondsToTimeString(
            currentSecondsInRound,
          ); // <<< Use Helper
          await insertMessage(
            'RedBoxer',
            'BlueBoxer',
            i.toString(),
            timeString,
            (_random.nextInt(520) + 380).toString(),
            round3_3,
            matchIds[3],
          );
          messagesInserted++;
        }
      }
      debugPrint("Inserted $messagesInserted sample messages.");

      // 5. Insert Sample Training Data (Timestamp remains fully random HH:MM:SS)
      int trainingDataInserted = 0;
      for (int i = 0; i < 50; i++) {
        String device = _random.nextBool() ? 'BlueBoxer' : 'RedBoxer';
        String punchBy = device == 'BlueBoxer' ? 'RedBoxer' : 'BlueBoxer';
        // Keep timestamp fully random (00:00:00 to 23:59:59) for training data
        String timeString =
            "${_random.nextInt(24).toString().padLeft(2, '0')}:${_random.nextInt(60).toString().padLeft(2, '0')}:${_random.nextInt(60).toString().padLeft(2, '0')}";
        await insertTrainingData(
          device,
          punchBy,
          (i + 1).toString(),
          timeString,
          (_random.nextInt(800) + 100).toString(),
        );
        trainingDataInserted++;
      }
      debugPrint(
        "Inserted $trainingDataInserted sample training data records.",
      );

      debugPrint("Comprehensive sample data insertion COMPLETE.");
    } catch (e, stacktrace) {
      debugPrint("Error inserting sample data: $e");
      debugPrint("Stacktrace: $stacktrace");
    }
  }

  // --- METHOD SIGNATURES AND UTILITY METHODS --- (No changes needed below this line)
  // Messages
  Future<void> insertMessage(
    String device,
    String oppositeDevice,
    String punchCount,
    String timestamp,
    String sensorValue,
    int roundId,
    int matchId,
  ) async {
    final db = await database;
    await db.insert('messages', {
      'device': device,
      'punchBy': oppositeDevice,
      'punchCount': punchCount,
      'timestamp': timestamp,
      'sensorValue': sensorValue,
      'roundId': roundId,
      'matchId': matchId,
    });
  }

  Future<List<Map<String, dynamic>>> fetchMessages() async {
    final db = await database;
    return await db.query('messages', orderBy: 'id DESC');
  }

  Future<List<Map<String, dynamic>>> fetchMessagesByMatchId(int matchId) async {
    final db = await database;
    return await db.query(
      'messages',
      where: 'matchId = ?',
      whereArgs: [matchId],
      orderBy: 'id DESC',
    );
  }

  Future<List<Map<String, dynamic>>> fetchMessagesByRoundId(int roundId) async {
    final db = await database;
    return await db.query(
      'messages',
      where: 'roundId = ?',
      whereArgs: [roundId],
      orderBy: 'id DESC',
    );
  }

  Future<void> clearMessages() async {
    final db = await database;
    await db.delete('messages');
    debugPrint("Cleared messages table.");
  }

  // Training Data
  Future<void> insertTrainingData(
    String device,
    String punchBy,
    String punchCount,
    String timestamp,
    String sensorValue,
  ) async {
    final db = await database;
    await db.insert('trainingdata', {
      'device': device,
      'punchBy': punchBy,
      'punchCount': punchCount,
      'timestamp': timestamp,
      'sensorValue': sensorValue,
    });
  }

  Future<List<Map<String, dynamic>>> fetchTrainingData() async {
    final db = await database;
    return await db.query('trainingdata', orderBy: 'id DESC');
  }

  Future<void> clearTrainingData() async {
    final db = await database;
    await db.delete('trainingdata');
    debugPrint("Cleared trainingdata table.");
  }

  // Settings
  Future<void> upsertSettings({
    required int fsrSensitivity,
    required int fsrThreshold,
    required int rounds,
    required int roundTime,
    required int breakTime,
    required int secondsBeforeRoundBegins,
  }) async {
    final db = await database;
    await db.insert('settings', {
      'id': 1,
      'fsrSensitivity': fsrSensitivity,
      'fsrThreshold': fsrThreshold,
      'rounds': rounds,
      'roundTime': roundTime,
      'breakTime': breakTime,
      'secondsBeforeRoundBegins': secondsBeforeRoundBegins,
    }, conflictAlgorithm: ConflictAlgorithm.replace);
    debugPrint("Settings upserted.");
  }

  Future<Map<String, dynamic>?> fetchSettings() async {
    final db = await database;
    final List<Map<String, dynamic>> settings = await db.query(
      'settings',
      where: 'id = ?',
      whereArgs: [1],
      limit: 1,
    );
    if (settings.isNotEmpty) {
      return settings.first;
    } else {
      debugPrint("Warning: Settings not found, returning null.");
      return null;
    }
  }

  Future<void> clearSettings() async {
    final db = await database;
    await _insertDefaultSettings(db);
    debugPrint("Settings reset to default.");
  }

  // Matches
  Future<int> insertMatch({
    required String matchName,
    required int rounds,
    required String matchDate,
    required int roundTime,
    required int breakTime,
  }) async {
    final db = await database;
    final Map<String, dynamic> matchData = {
      'matchName': matchName,
      'rounds': rounds,
      'matchDate': matchDate,
      'roundTime': roundTime,
      'breakTime': breakTime,
      'finishedAtRound': 0,
      'totalTime': '00:00',
    };
    final id = await db.insert('matches', matchData);
    debugPrint("Inserted match with ID: $id");
    return id;
  }

  Future<void> updateEditMatch({
    required int id,
    required String matchName,
    required String matchDate,
    required int rounds,
    required int finishedAtRound,
    required String totalTime,
    required int roundTime,
    required int breakTime,
  }) async {
    final db = await database;
    await db.update(
      'matches',
      {
        'matchName': matchName,
        'matchDate': matchDate,
        'rounds': rounds,
        'finishedAtRound': finishedAtRound,
        'totalTime': totalTime,
        'roundTime': roundTime,
        'breakTime': breakTime,
      },
      where: 'id = ?',
      whereArgs: [id],
    );
    debugPrint("Updated match with ID: $id");
  }

  Future<List<Map<String, dynamic>>> fetchMatches() async {
    final db = await database;
    return await db.query('matches', orderBy: 'id ASC');
  }

  Future<void> deleteMatch(int id) async {
    final db = await database;
    int count = await db.delete('matches', where: 'id = ?', whereArgs: [id]);
    if (count > 0) {
      debugPrint("Deleted match with ID: $id and related data.");
    } else {
      debugPrint("Match with ID: $id not found for deletion.");
    }
  }

  Future<Map<String, dynamic>?> fetchMatchById(int id) async {
    final db = await database;
    final result = await db.query(
      'matches',
      where: 'id = ?',
      whereArgs: [id],
      limit: 1,
    );
    return result.isNotEmpty ? result.first : null;
  }

  Future<void> clearMatches() async {
    final db = await database;
    await db.delete('matches');
    debugPrint("Cleared matches table and related data.");
  }

  Future<void> insertSampleMatchesOnly() async {
    debugPrint("Inserting sample matches ONLY...");
    List<Map<String, dynamic>> sampleMatches = [
      {
        'matchName': 'Basic 1',
        'rounds': 1,
        'matchDate': '2025-01-01',
        'roundTime': 60,
        'breakTime': 10,
      },
      {
        'matchName': 'Basic 2',
        'rounds': 3,
        'matchDate': '2025-01-02',
        'roundTime': 180,
        'breakTime': 60,
      },
    ];
    int count = 0;
    for (var match in sampleMatches) {
      await insertMatch(
        matchName: match['matchName'],
        rounds: match['rounds'],
        matchDate: match['matchDate'],
        roundTime: match['roundTime'],
        breakTime: match['breakTime'],
      );
      count++;
    }
    debugPrint("Inserted $count sample matches only.");
  }

  // Events
  Future<String> insertEvent({required int matchId, String? winner}) async {
    final db = await database;
    String eventId = _uuid.v4();
    await db.insert('events', {
      'id': eventId,
      'timestamp': DateTime.now().millisecondsSinceEpoch,
      'matchId': matchId,
      'winner': winner,
    });
    debugPrint("Inserted event $eventId for Match ID $matchId");
    return eventId;
  }

  Future<List<Map<String, dynamic>>> fetchEvents() async {
    final db = await database;
    return await db.query('events', orderBy: 'timestamp DESC');
  }

  Future<List<Map<String, dynamic>>> fetchEventsByMatchId(int matchId) async {
    final db = await database;
    return await db.query(
      'events',
      where: 'matchId = ?',
      whereArgs: [matchId],
      orderBy: 'timestamp DESC',
    );
  }

  Future<void> clearEvents() async {
    final db = await database;
    await db.delete('events');
    debugPrint("Cleared events table.");
  }

  Future<void> updateCurrentEventWinner(String eventId, String? winner) async {
    final db = await database;
    await db.update(
      'events',
      {'winner': winner},
      where: 'id = ?',
      whereArgs: [eventId],
    );
    debugPrint("Updated winner for event $eventId");
  }

  // Rounds
  Future<int> insertRound({
    required int matchId,
    required int round,
    required String? eventId,
  }) async {
    final db = await database;
    final roundData = {
      'matchId': matchId,
      'round': round,
      'eventId': eventId,
      'timestamp': DateTime.now().millisecondsSinceEpoch,
    };
    int id = 0;
    try {
      id = await db.insert('rounds', roundData);
      debugPrint("Inserted round $round for Event $eventId, Round ID: $id");
    } on DatabaseException catch (e) {
      if (e.isUniqueConstraintError()) {
        debugPrint("Error: Round $round for Event $eventId already exists.");
      } else {
        debugPrint("Database error inserting round: $e");
      }
    }
    return id;
  }

  Future<List<Map<String, dynamic>>> fetchRounds() async {
    final db = await database;
    List<Map<String, dynamic>> rounds = await db.query(
      'rounds',
      orderBy: 'id DESC',
    );
    return rounds.map((round) {
      final timestamp = round['timestamp'];
      String humanReadableTimestamp = "N/A";
      if (timestamp != null && timestamp is int) {
        try {
          var date = DateTime.fromMillisecondsSinceEpoch(timestamp);
          humanReadableTimestamp =
              "${date.year}-${date.month.toString().padLeft(2, '0')}-${date.day.toString().padLeft(2, '0')} ${date.hour.toString().padLeft(2, '0')}:${date.minute.toString().padLeft(2, '0')}:${date.second.toString().padLeft(2, '0')}";
        } catch (e) {
          debugPrint("Error formatting timestamp $timestamp: $e");
        }
      }
      var mutableRound = Map<String, dynamic>.from(round);
      mutableRound['humanReadableTimestamp'] = humanReadableTimestamp;
      return mutableRound;
    }).toList();
  }

  Future<void> clearRounds() async {
    final db = await database;
    await db.delete('rounds');
    debugPrint("Cleared rounds table.");
  }

  // Utilities
  Future<Map<String, int>> getEventPunchCounts(String eventId) async {
    final db = await database;
    final eventRounds = await db.query(
      'rounds',
      columns: ['id'],
      where: 'eventId = ?',
      whereArgs: [eventId],
    );
    if (eventRounds.isEmpty) {
      return {'BlueBoxer': 0, 'RedBoxer': 0};
    }
    final roundIds = eventRounds.map((r) => r['id'] as int).toList();
    final messages = await db.query(
      'messages',
      columns: ['punchBy'],
      where: 'roundId IN (${List.filled(roundIds.length, '?').join(',')})',
      whereArgs: roundIds,
    );
    int blue = 0;
    int red = 0;
    for (final msg in messages) {
      final who = msg['punchBy'] as String?;
      if (who == 'BlueBoxer') {
        blue++;
      } else if (who == 'RedBoxer') {
        red++;
      }
    }
    return {'BlueBoxer': blue, 'RedBoxer': red};
  }

  Future<Map<String, int>> getRoundPunchCounts(int roundId) async {
    final db = await database;
    final messages = await db.query(
      'messages',
      columns: ['punchBy'],
      where: 'roundId = ?',
      whereArgs: [roundId],
    );
    int blue = 0;
    int red = 0;
    for (final msg in messages) {
      final who = msg['punchBy'] as String?;
      if (who == 'BlueBoxer') {
        blue++;
      } else if (who == 'RedBoxer') {
        red++;
      }
    }
    return {'BlueBoxer': blue, 'RedBoxer': red};
  }
} // End of DatabaseHelper class