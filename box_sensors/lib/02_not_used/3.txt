  // Future<void> _loadHistory() async {
  //   try {
  //     await ref
  //         .read(bluetoothManagerProvider)
  //         .loadHistory(matchId: widget.match?['id']);
  //   } catch (_) {}
  // }



  // Future<List<Map<String, dynamic>>> _fetchEvents() async {
  //   try {
  //     final events = await dbHelper.fetchEventsByMatchId(widget.match['id']);
  //     return Future.wait(events.map((event) async {
  //       final counts = await dbHelper.getEventPunchCounts(event['id']);
  //       event['punchCounts'] = counts;
  //       return event;
  //     }));
  //   } catch (e, st) {
  //     debugPrint('Error fetching events: $e\n$st');
  //     return [];
  //   }
  // }










                             // TextFormField(
                              //   controller: totalTimeController,
                              //   decoration: InputDecoration(
                              //     border: OutlineInputBorder(),
                              //     filled: true,
                              //     fillColor: theme.colorScheme.surface,
                              //     labelText: 'Total Time (MM:SS)',
                              //     hintText: 'MM:SS',
                              //     isDense: true,
                              //     contentPadding: EdgeInsets.symmetric(
                              //       vertical: 8,
                              //       horizontal: 10,
                              //     ),
                              //   ),
                              //   keyboardType: TextInputType.number,
                              //   inputFormatters: [CustomTimeInputFormatter()],
                              //   validator: (value) {
                              //     if (value == null || value.isEmpty) {
                              //       return 'Please enter total time';
                              //     }
                              //     // Fix the regex: end-of-string is "$", not "\$"
                              //     if (!RegExp(
                              //       r'^\d{2}:\d{2}$',
                              //     ).hasMatch(value)) {
                              //       return 'Invalid format! Use MM:SS';
                              //     }
                              //     final parts = value.split(':');
                              //     final minutes = int.tryParse(parts[0]) ?? -1;
                              //     final seconds = int.tryParse(parts[1]) ?? -1;
                              //     // seconds must be 0–59, and you can cap minutes at, say, 0–99
                              //     if (minutes < 0 ||
                              //         minutes > 99 ||
                              //         seconds < 0 ||
                              //         seconds > 59) {
                              //       return 'Minutes: 00–99, Seconds: 00–59';
                              //     }
                              //     return null;
                              //   },
                              // ),

















            Expanded(
              child: ElevatedButton(
                onPressed: onAdd,
                style: ElevatedButton.styleFrom(
                  backgroundColor: theme.colorScheme.primary,
                  foregroundColor: theme.colorScheme.onPrimary,
                  elevation: 6,
                  shadowColor: theme.shadowColor,
                  surfaceTintColor: theme.colorScheme.primaryContainer,
                ),
                child: const Text('Add New Game', textAlign: TextAlign.center),
              ),
            ),


            Expanded(
              child: ElevatedButton(
                onPressed: onAdd,

                style: ElevatedButton.styleFrom(
                  backgroundColor: theme.colorScheme.primary,
                  foregroundColor: theme.colorScheme.onPrimary,
                  elevation: 6,
                  shadowColor: theme.shadowColor,
                  surfaceTintColor: theme.colorScheme.primaryContainer,
                ),
                child: Padding(
                  padding: const EdgeInsets.symmetric(horizontal: 8.0),
                  child: Text(
                    'Add New Game',
                    textAlign: TextAlign.center,
                    style: TextStyle(
                      color: theme.colorScheme.onPrimary,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ),
              ),
            ),












// Good code state 
// import 'dart:async';
// import 'dart:convert';
// import 'package:flutter/material.dart';
// import 'package:flutter_riverpod/flutter_riverpod.dart';
// import 'package:box_sensors/services/providers.dart';
// import 'package:box_sensors/services/bluetooth_manager.dart';
// import 'package:box_sensors/services/database_helper.dart';
// import 'package:box_sensors/widgets/display_row.dart';
// import 'package:box_sensors/widgets/common_buttons.dart';
// import 'package:sentry_flutter/sentry_flutter.dart';

// class StartMatchScreen extends ConsumerStatefulWidget {
//   final Stream<List<DataRow>> dataTableStream;
//   final Function(String) sendMessage;
//   final Map<String, dynamic>? match;

//   const StartMatchScreen({
//     super.key,
//     required this.dataTableStream,
//     required this.sendMessage,
//     this.match,
//   });

//   @override
//   ConsumerState<StartMatchScreen> createState() => _StartMatchScreenState();
// }

// class _StartMatchScreenState extends ConsumerState<StartMatchScreen> {
//   final List<DataRow> tableRows = [];
//   late final DatabaseHelper dbHelper;
//   Map<String, dynamic>? settings;
//   late Map<String, dynamic>? matchData;
//   String matchTimeCounter = "";

//   static const int start = 1, pause = 2, resume = 3, end = 5;
//   static const List<String> tableHeaders = [
//     'Device', 'PunchBy', 'PunchCount', 'Timestamp', 'Sensor',
//   ];

//   Timer? _dialogCountdownTimer;
//   final ValueNotifier<int> _countdownNotifier = ValueNotifier<int>(0);

//   @override
//   void initState() {
//     super.initState();
//     dbHelper = ref.read(databaseHelperProvider);
//     matchData = widget.match;
//     _loadSettings();
//     _loadMessagesFromDatabase();
//   }

//   @override
//   void dispose() {
//     _dialogCountdownTimer?.cancel();
//     _countdownNotifier.dispose();
//     super.dispose();
//   }

//   @override
//   Widget build(BuildContext context) {
//     final screenWidth = MediaQuery.of(context).size.width;
//     double tableWidth = screenWidth * 0.95;
//     if (tableWidth < 350) tableWidth = 350;

//     final bluetoothManager = ref.watch(bluetoothManagerProvider);
//     final timerState = ref.watch(timerStateProvider);
//     final theme = Theme.of(context);

//     return PopScope(
//       canPop: !timerState.isStartButtonDisabled || timerState.isEndMatch,
//       onPopInvokedWithResult: (didPop, result) {},
//       child: Scaffold(
//         body: SafeArea(
//           child: Column(
//             children: [
//               // AppBar replacement with back button
//               DisplayRow(
//                 fontSize: 14,
//                 title: 'Start Game: ${matchData?['matchName']}',
//                 actions: [
//                   IconButton(
//                     icon: Icon(Icons.arrow_back, color: theme.colorScheme.onSurface),
//                     onPressed: timerState.isEndMatch || !timerState.isStartButtonDisabled
//                         ? () => Navigator.pop(context)
//                         : null,
//                   ),
//                 ],
//               ),
//               const SizedBox(height: 2),

//               // Round / Break / Ended display
//               Padding(
//                 //padding: const EdgeInsets.symmetric(horizontal: 8.0, vertical: 4.0),
//                 padding: const EdgeInsets.symmetric(horizontal: 4.0),
//                 child: Center(
//                   child: Text(
//                     timerState.isEndMatch
//                         ? 'Match Ended – Total rounds: ${timerState.totalRounds}'
//                         : timerState.isBreak
//                             ? 'Break time: ${timerState.countdown}s left'
//                             : 'Round ${timerState.round}: ${timerState.countdown}s left',
//                     style: TextStyle(
//                       fontSize: 16,
//                       fontWeight: FontWeight.bold,
//                       color: theme.colorScheme.primary,
//                     ),
//                   ),
//                 ),
//               ),

//               // Controls card
//               Card(
//                 elevation: 4,
//                 shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
//                 margin: const EdgeInsets.all(8),
//                 child: Padding(
//                   padding: const EdgeInsets.all(4.0),
//                   child: Row(
//                     mainAxisAlignment: MainAxisAlignment.spaceEvenly,
//                     children: [
//                       Column(
//                         children: [
//                           CommonButtons.buildRoundControlButton(
//                             context,
//                             'Start Match',
//                             timerState.isStartButtonDisabled
//                                 ? null
//                                 : () async {
//                                     try {
//                                       setState(() => timerState.isStartButtonDisabled = true);
//                                       bluetoothManager.clearTable();
//                                       setState(() => tableRows.clear());
//                                       await _loadSettings();
//                                       await loadMatchSettingsAndStartGame(bluetoothManager);
//                                     } catch (e, st) {
//                                       Sentry.captureException(e, stackTrace: st);
//                                     }
//                                   },
//                             theme,
//                           ),
//                           const SizedBox(height: 4),
//                           CommonButtons.buildRoundControlButton(
//                             context,
//                             'Pause Match',
//                             timerState.isPauseButtonDisabled
//                                 ? null
//                                 : () {
//                                     final json = _genRoundJson(pause);
//                                     bluetoothManager.sendMessageToAllConnectedDevices(json);
//                                     timerState.pauseTimer();
//                                   },
//                             theme,
//                           ),
//                         ],
//                       ),
//                       Column(
//                         children: [
//                           CommonButtons.buildRoundControlButton(
//                             context,
//                             'End Match',
//                             timerState.isEndButtonDisabled
//                                 ? null
//                                 : () {
//                                     final json = _genRoundJson(end);
//                                     bluetoothManager.sendMessageToAllConnectedDevices(json);
//                                     timerState.endMatchManually();
//                                   },
//                             theme,
//                           ),
//                           const SizedBox(height: 4),
//                           CommonButtons.buildRoundControlButton(
//                             context,
//                             'Resume Match',
//                             timerState.isResumeButtonDisabled
//                                 ? null
//                                 : () {
//                                     final json = _genRoundJson(resume);
//                                     bluetoothManager.sendMessageToAllConnectedDevices(json);
//                                     timerState.resumeTimer();
//                                   },
//                             theme,
//                           ),
//                         ],
//                       ),
//                     ],
//                   ),
//                 ),
//               ),

//               // Data table
//               Expanded(
//                 child: SingleChildScrollView(
//                   scrollDirection: Axis.horizontal,
//                   child: ConstrainedBox(
//                     constraints: BoxConstraints(minWidth: tableWidth),
//                     child: Column(
//                       children: [
//                         _buildTableHeader(theme, tableWidth),
//                         const Divider(height: 1, thickness: 1),
//                         Expanded(
//                           child: SingleChildScrollView(
//                             child: _buildTableBody(bluetoothManager, tableWidth),
//                           ),
//                         ),
//                       ],
//                     ),
//                   ),
//                 ),
//               ),
//             ],
//           ),
//         ),
//       ),
//     );
//   }

//    Widget _buildTableHeader(ThemeData theme, double tableWidth) {
//     return Container(
//       width: tableWidth,
//       color: theme.colorScheme.surfaceTint,
//       child: Row(
//         children: tableHeaders.map((header) => _buildHeaderCell(header, theme)).toList(),
//       ),
//     );
//   }
  
//    Widget _buildHeaderCell(String text, ThemeData theme) {
//     return Expanded(
//       flex: 1,
//       child: Container(
//         color: theme.colorScheme.primary,
//         child: Center(
//           child: Text(text, style: TextStyle(fontWeight: FontWeight.bold, fontSize: 11.0, color: theme.colorScheme.onPrimary)),
//         ),
//       ),
//     );
//   }

//   Widget _buildTableBody(BluetoothManager mgr, double width) {
//     return StreamBuilder<List<DataRow>>(
//       //stream: bluetoothManager.messageStream,
//       stream: mgr.messageStream,
//       builder: (context, snapshot) {
//         final rowsToDisplay =
//             snapshot.hasData && snapshot.data!.isNotEmpty ? snapshot.data! : tableRows;
//         if (rowsToDisplay.isEmpty) {
//           return const Center(child: Text('No sensor(s) data yet.'));
//         }
//         return Scrollbar(
//           child: SingleChildScrollView(
//             child: Column(
//               children: rowsToDisplay.reversed.map((dataRow) {
//                 return IntrinsicHeight(
//                   child: Row(
//                     children: dataRow.cells.map((dataCell) {
//                       return Container(
//                         width: width / tableHeaders.length,
//                         padding: const EdgeInsets.all(1),
//                         alignment: Alignment.center,
//                         child: dataCell.child,
//                       );
//                     }).toList(),
//                   ),
//                 );
//               }).toList(),
//             ),
//           ),
//         );
//       },
//     );
//   }

//   Future<void> loadMatchSettingsAndStartGame(BluetoothManager mgr) async {
//     final timerState = ref.read(timerStateProvider);
//     final current = widget.match;
//     timerState.rounds = current?['rounds'] ?? 1;
//     timerState.totalRounds = timerState.rounds;
//     timerState.roundTime = ((current?['roundTime'] ?? 3) * 60);
//     timerState.breakTime = current?['breakTime'] ?? 60;

//     try {
//       final eventId = await dbHelper.insertEvent(matchId: current?['id'] ?? 0);
//       timerState.initialize(dbHelper, mgr, current?['id'], eventId);
//     } catch (e, st) {
//       Sentry.captureException(e, stackTrace: st);
//     }

//     if (!mounted) return;
//     _showCountdown(mgr);
//   }

//   Future<void> _loadSettings() async {
//     try {
//       settings = await dbHelper.fetchSettings();
//       setState(() {});
//     } catch (e, st) {
//       Sentry.captureException(e, stackTrace: st);
//     }
//   }

//   Future<void> _loadMessagesFromDatabase() async {
//     try {
//       await ref
//           .read(bluetoothManagerProvider)
//           .loadHistory(matchId: widget.match?['id']);
//     } catch (_) {}
//   }

//   String _genRoundJson(int cmd) => jsonEncode({
//         'RoundStatusCommand': {'Command': cmd},
//       });

//   void _showCountdown(BluetoothManager mgr) {
//     if (!mounted || settings == null) return;
//     final dialogContext = context;
//     final secs = settings!['secondsBeforeRoundBegins'] ?? 5;
//     _countdownNotifier.value = secs;
//     _dialogCountdownTimer?.cancel();

//     showDialog(
//       context: dialogContext,
//       barrierDismissible: false,
//       builder: (ctx) {
//         _dialogCountdownTimer = Timer.periodic(
//           const Duration(seconds: 1),
//           (t) {
//             if (_countdownNotifier.value > 0) {
//               _countdownNotifier.value--;
//             } else {
//               t.cancel();
//               Navigator.of(ctx, rootNavigator: true).pop();
//               ref.read(timerStateProvider).startCountdown(() async {
//                 final jsonSettings = await _genSettingsJson();
//                 mgr.sendMessageToAllConnectedDevices(jsonSettings);
//                 mgr.sendMessageToAllConnectedDevices(_genRoundJson(start));
//               });
//             }
//           },
//         );

//         return AlertDialog(
//           shape:
//               RoundedRectangleBorder(borderRadius: BorderRadius.circular(15)),
//           title: Row(
//             children: [
//               Icon(Icons.hourglass_top,
//                   color: Theme.of(ctx).colorScheme.primary),
//               const SizedBox(width: 8),
//               const Text('Get Ready!',
//                   style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold)),
//             ],
//           ),
//           content: Column(
//             mainAxisSize: MainAxisSize.min,
//             children: [
//               Text('Starting in…',
//                   style: TextStyle(fontSize: 16,
//                       fontWeight: FontWeight.w500,
//                       //color: Colors.grey
//                       color: Theme.of(dialogContext).colorScheme.primary,
//                       )),
//               const SizedBox(height: 16),
//               ValueListenableBuilder<int>(
//                 valueListenable: _countdownNotifier,
//                 builder: (_, value, __) => Text('$value',
//                     style: TextStyle(
//                         fontSize: 48, fontWeight: FontWeight.bold,
//                         color: Theme.of(dialogContext).colorScheme.primary)),
//               ),
//               const SizedBox(height: 16),
//               ValueListenableBuilder<int>(
//                 valueListenable: _countdownNotifier,
//                 builder: (_, value, __) {
//                   final progress = (secs - value) / secs;
//                   return LinearProgressIndicator(
//                     value: progress,
//                     backgroundColor: Colors.grey[300],
//                     valueColor: AlwaysStoppedAnimation<Color>(
//                         Theme.of(ctx).colorScheme.primary),
//                   );
//                 },
//               ),
//             ],
//           ),
//         );
//       },
//     ).then((_) => _dialogCountdownTimer?.cancel());
//   }

//   Future<String> _genSettingsJson() async {
//     final s = await dbHelper.fetchSettings();
//     return jsonEncode({
//       'SensorSettings': {
//         'FsrSensitivity': s!['fsrSensitivity'].toString(),
//         'FsrThreshold': s['fsrThreshold'].toString(),
//         'RoundTime':
//             ((widget.match?['roundTime'] ?? s['roundTime']) * 60000).toString(),
//         'BreakTime':
//             ((widget.match?['breakTime'] ?? s['breakTime']) * 1000).toString(),
//       },
//     });
//   }
// }
















// import 'dart:async';
// import 'dart:convert';
// import 'package:flutter/material.dart';
// import 'package:flutter_riverpod/flutter_riverpod.dart';
// import 'package:sentry_flutter/sentry_flutter.dart';
// import 'package:box_sensors/services/providers.dart';
// import 'package:box_sensors/services/bluetooth_manager.dart';
// import 'package:box_sensors/services/database_helper.dart';
// import 'package:box_sensors/screens/start_match_header.dart';
// import 'package:box_sensors/screens/round_controls_card.dart';
// import 'package:box_sensors/screens/match_data_table.dart';

// class StartMatchScreen extends ConsumerStatefulWidget {
//   final Stream<List<DataRow>> dataTableStream;
//   final Map<String, dynamic>? match;
//   const StartMatchScreen({
//     super.key,
//     required this.dataTableStream,
//     this.match,
//   });

//   @override
//   ConsumerState<StartMatchScreen> createState() => _StartMatchScreenState();
// }

// class _StartMatchScreenState extends ConsumerState<StartMatchScreen> {
//   late final DatabaseHelper dbHelper;
//   Map<String, dynamic>? settings;
//   Timer? _dialogCountdownTimer;
//   final ValueNotifier<int> _countdownNotifier = ValueNotifier<int>(0);

//   static const int start = 1, pause = 2, resume = 3, end = 5;

//   @override
//   void initState() {
//     super.initState();
//     dbHelper = ref.read(databaseHelperProvider);
//     _loadSettings();
//     _loadHistory();
//   }

//   @override
//   void dispose() {
//     _dialogCountdownTimer?.cancel();
//     _countdownNotifier.dispose();
//     super.dispose();
//   }

//   @override
//   Widget build(BuildContext context) {
//     final bluetoothManager = ref.watch(bluetoothManagerProvider);
//     final timerState = ref.watch(timerStateProvider);
//     final theme = Theme.of(context);

//     return PopScope(
//       canPop: !timerState.isStartButtonDisabled || timerState.isEndMatch,
//       onPopInvokedWithResult: (_, __) {},
//       child: Scaffold(
//         body: SafeArea(
//           child: Column(
//             children: [
//               // HEADER + BACK BUTTON
//               StartMatchHeader(
//                 matchName: widget.match?['matchName'],
//                 timerState: timerState,
//                 theme: theme,
//               ),

//               // ROUND / BREAK / ENDED COUNTER
//               Padding(
//                 padding: const EdgeInsets.symmetric(vertical: 8.0),
//                 child: Text(
//                   timerState.isEndMatch
//                       ? 'Match Ended – Total Rounds: ${timerState.totalRounds}'
//                       : timerState.isBreak
//                           ? 'Break time: ${timerState.countdown}s left'
//                           : 'Round ${timerState.round}: ${timerState.countdown}s left',
//                   style: TextStyle(
//                     fontSize: 16,
//                     fontWeight: FontWeight.bold,
//                     color: theme.colorScheme.primary,
//                   ),
//                 ),
//               ),

//               // CONTROLS
//               RoundControlsCard(
//                 theme: theme,
//                 isStartDisabled: timerState.isStartButtonDisabled,
//                 isEndDisabled: timerState.isEndButtonDisabled,
//                 isPauseDisabled: timerState.isPauseButtonDisabled,
//                 isResumeDisabled: timerState.isResumeButtonDisabled,
//                 onStart: () async {
//                   try {
//                     bluetoothManager.clearTable();
//                     await _loadSettings();
//                     final eventId =
//                         await dbHelper.insertEvent(matchId: widget.match?['id']);
//                     ref.read(timerStateProvider).initialize(
//                           dbHelper,
//                           bluetoothManager,
//                           widget.match?['id'],
//                           eventId,   /// <----------------------eventId!-----------------------------------------
//                         );
//                   } catch (e, st) {
//                     Sentry.captureException(e, stackTrace: st);
//                   }
//                 },
//                 onPause: () {
//                   final json = _genRoundJson(pause);
//                   bluetoothManager.sendMessageToAllConnectedDevices(json);
//                   ref.read(timerStateProvider).pauseTimer();
//                 },
//                 onResume: () {
//                   final json = _genRoundJson(resume);
//                   bluetoothManager.sendMessageToAllConnectedDevices(json);
//                   ref.read(timerStateProvider).resumeTimer();
//                 },
//                 onEnd: () {
//                   final json = _genRoundJson(end);
//                   bluetoothManager.sendMessageToAllConnectedDevices(json);
//                   ref.read(timerStateProvider).endMatchManually();
//                 },
//                 // only show the dialog after Start’s async work is done
//                 showCountdownDialog: () {
//                   if (!mounted || settings == null) return;
//                   _showCountdown(bluetoothManager);
//                 },
//               ),

//               // DATA TABLE
//               const SizedBox(height: 8),
//               Expanded(
//                 child: MatchDataTable(
//                   tableStream: widget.dataTableStream,
//                   tableWidthProvider: () {
//                     final w = MediaQuery.of(context).size.width * 0.95;
//                     return w < 350 ? 350 : w;
//                   },
//                 ),
//               ),
//             ],
//           ),
//         ),
//       ),
//     );
//   }

//   Future<void> _loadSettings() async {
//     try {
//       settings = await dbHelper.fetchSettings();
//     } catch (e, st) {
//       Sentry.captureException(e, stackTrace: st);
//     }
//   }

//   Future<void> _loadHistory() async {
//     try {
//       await ref
//           .read(bluetoothManagerProvider)
//           .loadHistory(matchId: widget.match?['id']);
//     } catch (_) {}
//   }

//   String _genRoundJson(int cmd) => jsonEncode({
//         'RoundStatusCommand': {'Command': cmd},
//       });

//   void _showCountdown(BluetoothManager mgr) {
//     if (!mounted) return;
//     final dialogContext = context;
//     final secs = settings!['secondsBeforeRoundBegins'] ?? 5;
//     _countdownNotifier.value = secs;
//     _dialogCountdownTimer?.cancel();

//     showDialog(
//       context: dialogContext,
//       barrierDismissible: false,
//       builder: (dialogContext) {
//         // kick off the timer *inside* the builder so we get a fresh dialogContext
//         _dialogCountdownTimer = Timer.periodic(
//           const Duration(seconds: 1),
//           (timer) {
//             if (_countdownNotifier.value > 0) {
//               _countdownNotifier.value--;
//             } else {
//               timer.cancel();
//               Navigator.of(dialogContext, rootNavigator: true).pop();
//               ref.read(timerStateProvider).startCountdown(() async {
//                 final settingsJson = await _genSettingsJson();
//                 mgr.sendMessageToAllConnectedDevices(settingsJson);
//                 mgr.sendMessageToAllConnectedDevices(_genRoundJson(start));
//               });
//             }
//           },
//         );

//         return AlertDialog(
//           shape:
//               RoundedRectangleBorder(borderRadius: BorderRadius.circular(15)),
//           title: Row(
//             children: [
//               Icon(Icons.hourglass_top,
//                   color: Theme.of(dialogContext).colorScheme.primary),
//               const SizedBox(width: 8),
//               const Text('Get Ready!',
//                   style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold)),
//             ],
//           ),
//           content: Column(
//             mainAxisSize: MainAxisSize.min,
//             children: [
//               const Text('Starting in…',
//                   style: TextStyle(
//                       fontSize: 16,
//                       fontWeight: FontWeight.w500,
//                       color: Colors.grey)),
//               const SizedBox(height: 16),
//               ValueListenableBuilder<int>(
//                 valueListenable: _countdownNotifier,
//                 builder: (_, value, __) => Text('$value',
//                     style:
//                         const TextStyle(fontSize: 48, fontWeight: FontWeight.bold)),
//               ),
//               const SizedBox(height: 16),
//               ValueListenableBuilder<int>(
//                 valueListenable: _countdownNotifier,
//                 builder: (_, value, __) {
//                   final progress = (secs - value) / secs;
//                   return LinearProgressIndicator(
//                     value: progress,
//                     backgroundColor: Colors.grey[300],
//                     valueColor: AlwaysStoppedAnimation<Color>(
//                         Theme.of(dialogContext).colorScheme.primary),
//                   );
//                 },
//               ),
//             ],
//           ),
//         );
//       },
//     ).then((_) => _dialogCountdownTimer?.cancel());
//   }

//   Future<String> _genSettingsJson() async {
//     final s = await dbHelper.fetchSettings();
//     return jsonEncode({
//       'SensorSettings': {
//         'FsrSensitivity': s!['fsrSensitivity'].toString(),
//         'FsrThreshold': s['fsrThreshold'].toString(),
//         'RoundTime':
//             ((widget.match?['roundTime'] ?? s['roundTime']) * 60000).toString(),
//         'BreakTime':
//             ((widget.match?['breakTime'] ?? s['breakTime']) * 1000).toString(),
//       },
//     });
//   }
// }















// // lib/screens/start_match_screen.dart
// import 'dart:async';
// import 'dart:convert';
// import 'package:flutter/material.dart';
// import 'package:flutter_riverpod/flutter_riverpod.dart';
// import 'package:sentry_flutter/sentry_flutter.dart';
// import 'package:box_sensors/services/providers.dart';
// import 'package:box_sensors/services/bluetooth_manager.dart';
// import 'package:box_sensors/services/database_helper.dart';
// import 'package:box_sensors/screens/start_match_header.dart';
// import 'package:box_sensors/screens/round_controls_card.dart';
// import 'package:box_sensors/screens/match_data_table.dart';

// class StartMatchScreen extends ConsumerStatefulWidget {
//   final Stream<List<DataRow>> dataTableStream;
//   final Function(String) sendMessage;
//   final Map<String, dynamic>? match;

//   const StartMatchScreen({
//     super.key,
//     required this.dataTableStream,
//     required this.sendMessage,
//     this.match,
//   });

//   @override
//   ConsumerState<StartMatchScreen> createState() => _StartMatchScreenState();
// }

// class _StartMatchScreenState extends ConsumerState<StartMatchScreen> {
//   late final DatabaseHelper dbHelper;
//   Map<String, dynamic>? settings;
//   Map<String, dynamic>? matchData;

//   Timer? _dialogCountdownTimer;
//   final ValueNotifier<int> _countdownNotifier = ValueNotifier<int>(0);

//   static const int start = 1;
//   static const int pause = 2;
//   static const int resume = 3;
//   static const int end = 5;

//   @override
//   void initState() {
//     super.initState();
//     dbHelper = ref.read(databaseHelperProvider);
//     matchData = widget.match;
//     _loadSettings();
//     _loadHistory();
//   }

//   @override
//   void dispose() {
//     _dialogCountdownTimer?.cancel();
//     _countdownNotifier.dispose();
//     super.dispose();
//   }

//   @override
//   Widget build(BuildContext context) {
//     final bluetoothManager = ref.watch(bluetoothManagerProvider);
//     final timerState = ref.watch(timerStateProvider);
//     final theme = Theme.of(context);

//     return PopScope(
//       canPop: !timerState.isStartButtonDisabled || timerState.isEndMatch,
//       onPopInvokedWithResult: (_, __) {},
//       child: Scaffold(
//         body: SafeArea(
//           child: Column(
//             children: [
//               StartMatchHeader(
//                 matchName: matchData?['matchName'],
//                 timerState: timerState,
//                 theme: theme,
//               ),
//               const SizedBox(height: 8),

//               RoundControlsCard(
//                 theme: theme,
//                 isStartDisabled: timerState.isStartButtonDisabled,
//                 isEndDisabled: timerState.isEndButtonDisabled,
//                 isPauseDisabled: timerState.isPauseButtonDisabled,
//                 isResumeDisabled: timerState.isResumeButtonDisabled,
//                 onStart: () async {
//                   try {
//                     bluetoothManager.clearTable();
//                     await _loadSettings();
//                     await _startMatch(bluetoothManager);
//                     if (!mounted) return;
//                     _showCountdown(bluetoothManager);
//                   } catch (e, st) {
//                     Sentry.captureException(e, stackTrace: st);
//                   }
//                 },
//                 onEnd: () async {
//                   try {
//                     final json = _genRoundJson(end);
//                     bluetoothManager.sendMessageToAllConnectedDevices(json);
//                     timerState.endMatchManually();
//                   } catch (e, st) {
//                     Sentry.captureException(e, stackTrace: st);
//                   }
//                 },
//                 onPause: () async {
//                   try {
//                     final json = _genRoundJson(pause);
//                     bluetoothManager.sendMessageToAllConnectedDevices(json);
//                     timerState.pauseTimer();
//                   } catch (e, st) {
//                     Sentry.captureException(e, stackTrace: st);
//                   }
//                 },
//                 onResume: () async {
//                   try {
//                     final json = _genRoundJson(resume);
//                     bluetoothManager.sendMessageToAllConnectedDevices(json);
//                     timerState.resumeTimer();
//                   } catch (e, st) {
//                     Sentry.captureException(e, stackTrace: st);
//                   }
//                 },
//                 showCountdownDialog: () {
//                   if (!mounted) return;
//                   _showCountdown(bluetoothManager);
//                 },
//               ),

//               const SizedBox(height: 8),

//               Expanded(
//                 child: MatchDataTable(
//                   tableStream: widget.dataTableStream,
//                   tableWidthProvider: () {
//                     final w = MediaQuery.of(context).size.width * 0.95;
//                     return w < 350 ? 350 : w;
//                   },
//                 ),
//               ),
//             ],
//           ),
//         ),
//       ),
//     );
//   }

//   Future<void> _loadSettings() async {
//     try {
//       settings = await dbHelper.fetchSettings();
//     } catch (e, st) {
//       Sentry.captureException(e, stackTrace: st);
//     }
//   }

//   Future<void> _loadHistory() async {
//     try {
//       final mgr = ref.read(bluetoothManagerProvider);
//       await mgr.loadHistory(matchId: widget.match?['id']);
//     } catch (_) {}
//   }

//   Future<void> _startMatch(BluetoothManager mgr) async {
//     final timerState = ref.read(timerStateProvider);
//     final eventId = await dbHelper.insertEvent(matchId: matchData?['id'] ?? 0);
//     timerState.initialize(dbHelper, mgr, matchData?['id'], eventId);
//   }

//   String _genRoundJson(int cmd) => jsonEncode({
//     "RoundStatusCommand": {"Command": cmd},
//   });

//   void _showCountdown(BluetoothManager mgr) {
//     if (!mounted) return;

//     final dialogContext = context; // grab it fresh, synchronously
//     final secs = settings?['secondsBeforeRoundBegins'] ?? 5;
//     _countdownNotifier.value = secs;
//     _dialogCountdownTimer?.cancel();

//     showDialog(
//       context: dialogContext,
//       barrierDismissible: false,
//       builder:
//           (_) => AlertDialog(
//             shape: RoundedRectangleBorder(
//               borderRadius: BorderRadius.circular(15),
//             ),
//             title: Row(
//               children: [
//                 Icon(
//                   Icons.hourglass_top,
//                   color: Theme.of(dialogContext).colorScheme.primary,
//                 ),
//                 const SizedBox(width: 8),
//                 const Text(
//                   'Get Ready!',
//                   style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold),
//                 ),
//               ],
//             ),
//             content: Column(
//               mainAxisSize: MainAxisSize.min,
//               children: [
//                 const Text(
//                   'Starting in...',
//                   style: TextStyle(
//                     fontSize: 16,
//                     fontWeight: FontWeight.w500,
//                     color: Colors.grey,
//                   ),
//                 ),
//                 ValueListenableBuilder<int>(
//                   valueListenable: _countdownNotifier,
//                   builder:
//                       (_, v, __) => Text(
//                         '$v',
//                         style: const TextStyle(
//                           fontSize: 48,
//                           fontWeight: FontWeight.bold,
//                         ),
//                       ),
//                 ),
//               ],
//             ),
//           ),
//     );

//     _dialogCountdownTimer = Timer.periodic(const Duration(seconds: 1), (t) {
//       if (_countdownNotifier.value > 0) {
//         _countdownNotifier.value--;
//       } else {
//         t.cancel();
//         Navigator.of(dialogContext, rootNavigator: true).pop();
//         final ts = ref.read(timerStateProvider);
//         ts.startCountdown(() async {
//           final settingsJson = await _genSettingsJson();
//           mgr.sendMessageToAllConnectedDevices(settingsJson);
//           mgr.sendMessageToAllConnectedDevices(_genRoundJson(start));
//         });
//       }
//     });
//   }

//   Future<String> _genSettingsJson() async {
//     final s = await dbHelper.fetchSettings();
//     return jsonEncode({
//       "SensorSettings": {
//         "FsrSensitivity": s!['fsrSensitivity'].toString(),
//         "FsrThreshold": s['fsrThreshold'].toString(),
//         "RoundTime":
//             ((matchData?['roundTime'] ?? s['roundTime']) * 60000).toString(),
//         "BreakTime":
//             ((matchData?['breakTime'] ?? s['breakTime']) * 1000).toString(),
//       },
//     });
//   }
// }



















  // to test it still have not been test it
    Future<void> updateRSSIForConnectedDevices() async {
    // Start with the connected devices that have a Bluetooth device instance.
    final deviceNames = connectedBluetoothDevices.entries
        .where((entry) => entry.value != null)
        .map((entry) => entry.key)
        .toSet();

    // Also include the target device names if marked as connected.
    const targetDevices = ['BlueBoxer', 'RedBoxer', 'BoxerServer'];
    for (final name in targetDevices) {
      if (connectedDevices[name] == true) {
        deviceNames.add(name);
      }
    }

    for (final deviceName in deviceNames) {
      final connectedDevice = connectedBluetoothDevices[deviceName];
      if (connectedDevice != null) {
        try {
          final rssi = await connectedDevice.readRssi();
          rssiValues[deviceName] = rssi;
          debugPrint("Updated RSSI for $deviceName: $rssi");
        } catch (e) {
          debugPrint("Error reading RSSI for $deviceName: $e");
          Sentry.captureException(e);
        }
      }
    }
    _scheduleUIUpdate(); // final UI update
  }














Final Note on AudioPlayer
For your audio player usage in TimerState, you have two choices:

Keep Instantiation in TimerState:
You already create an instance with final AudioPlayer _audioPlayer = AudioPlayer(); inside TimerState. This is acceptable if you don’t need to override or share the AudioPlayer instance.

Create an audioPlayerProvider (Optional):
If you want to make it available for dependency injection (for example, if you need to override for tests), then add in your providers file:

dart
Copy
final audioPlayerProvider = Provider<AudioPlayer>((ref) => AudioPlayer());
and then in your TimerState (or any other class), read it via:

dart
Copy
final AudioPlayer _audioPlayer = ref.read(audioPlayerProvider);
This is optional based on your project needs.











    // If the filter is empty, start a timer that periodically scans extra devices.
    // if (filterKeyword.trim().isEmpty) {
    //   _periodicExtraScanTimer =
    //       Timer.periodic(const Duration(seconds: 2), (timer) async {
    //     await widget.bluetoothManager.startScan(
    //       timeout: const Duration(seconds: 2),
    //       filterKeyword: '',
    //     );
    //   });
    // } 
 
 
 
 
 
 
 
  Future<void> disconnectAllDevicesold() async {
    for (final deviceName in connectedBluetoothDevices.keys) {
      if (connectedBluetoothDevices[deviceName] != null) {
        await handleDisconnectDevice(deviceName);
      }
    }
  }

  Future<void> disconnectAllDevices2() async {
    for (var deviceName in availableDevices) {
      _deviceConnectionNotifiers[deviceName]?.value = false;
      debugPrint('Disconnected $deviceName (notifier set to false)');
    }
    notifyListeners();
  }



  // Column(
                                      //   mainAxisSize: MainAxisSize.min,
                                      //   mainAxisAlignment:
                                      //       MainAxisAlignment.center,
                                      //   children: [
                                      //     ElevatedButton.icon(
                                      //       onPressed:
                                      //           widget.bluetoothManager
                                      //                   .isDeviceConnected(
                                      //                     deviceName,
                                      //                   )
                                      //               ? () => widget
                                      //                   .bluetoothManager
                                      //                   .handleDisconnectDevice(
                                      //                     deviceName,
                                      //                   )
                                      //               : null,
                                      //       icon: Icon(
                                      //         Icons.bluetooth_disabled,
                                      //         color:
                                      //             theme.colorScheme.onPrimary,
                                      //         size: 12,
                                      //       ),
                                      //       label: const Text('Disconnect'),
                                      //       style: ElevatedButton.styleFrom(
                                      //         backgroundColor:
                                      //             theme.colorScheme.primary,
                                      //         foregroundColor:
                                      //             theme.colorScheme.onPrimary,
                                      //         elevation: 6,
                                      //         shadowColor: theme.shadowColor,
                                      //         surfaceTintColor:
                                      //             theme
                                      //                 .colorScheme
                                      //                 .primaryContainer,
                                      //         fixedSize: const Size(138, 48),
                                      //       ),
                                      //     ),
                                      //   ],
                                      // ),




                                       // ElevatedButton.icon(
              //   // onPressed: () => widget.bluetoothManager.disconnectFromDevice(),  // disconnectAllDevices
              //   onPressed: () => widget.bluetoothManager.disconnectAllDevices(),
              //   icon: Icon(
              //     Icons.bluetooth_disabled,
              //     color: theme.colorScheme.onPrimary,
              //   ),
              //   label: const Text('Disconnect All Devices'),
              //   style: ElevatedButton.styleFrom(
              //     backgroundColor: theme.colorScheme.primary,
              //     foregroundColor: theme.colorScheme.onPrimary,
              //     elevation: 6,
              //     shadowColor: theme.shadowColor,
              //     surfaceTintColor: theme.colorScheme.primaryContainer,
              //     fixedSize: const Size(300, 40),
              //   ),
              // ),




















// // lib/screens/add_match_screen.dart
// import 'package:flutter/material.dart';
// import 'package:flutter_riverpod/flutter_riverpod.dart';
// import 'package:intl/intl.dart';
// import 'package:box_sensors/widgets/display_row.dart';
// import 'package:box_sensors/services/database_helper.dart';
// import 'package:box_sensors/services/providers.dart';
// import 'package:box_sensors/screens_widgets/match_info_card.dart';
// import 'package:box_sensors/screens_widgets/timings_card.dart';
// import 'package:box_sensors/screens_widgets/add_game_button.dart';
// // import 'package:box_sensors/screens/matches_screen.dart';

// /// implement this so ConnectHome can call resetForm()
// mixin AddMatchResettable on State<AddMatchScreen> {
//   void resetForm();
// }

// class AddMatchScreen extends ConsumerStatefulWidget {
//   final void Function(int)? onTabChange;

//   const AddMatchScreen({super.key, this.onTabChange});

//   @override
//   ConsumerState<AddMatchScreen> createState() => _AddMatchScreenState();
// }

// class _AddMatchScreenState extends ConsumerState<AddMatchScreen> {
//   final _formKey = GlobalKey<FormState>();
  
//   late final DatabaseHelper _dbHelper;

//   final _matchNameCtrl = TextEditingController();
//   final _matchDateCtrl = TextEditingController();
//   final _roundsCtrl = TextEditingController();
//   final _roundTimeCtrl = TextEditingController();
//   final _breakTimeCtrl = TextEditingController();

//   @override
//   void initState() {
//     super.initState();
//     _dbHelper = ref.read(databaseHelperProvider);
//     _matchDateCtrl.text = DateFormat('dd/MM/yyyy').format(DateTime.now());
//   }

//   @override
//   void dispose() {
//     _matchNameCtrl.dispose();
//     _matchDateCtrl.dispose();
//     _roundsCtrl.dispose();
//     _roundTimeCtrl.dispose();
//     _breakTimeCtrl.dispose();
//     super.dispose();
//   }

//   /// Called from ConnectHome when re-selecting the “Add” tab.
//   void _resetForm() {
//     _formKey.currentState?.reset();
//     _matchNameCtrl.clear();
//     _matchDateCtrl.text = DateFormat('dd/MM/yyyy').format(DateTime.now());
//     _roundsCtrl.clear();
//     _roundTimeCtrl.clear();
//     _breakTimeCtrl.clear();
//   }

//   /// Exactly like in SettingsScreen: safely show a SnackBar after this frame.
//   void _showSnackBar(String message) {
//     WidgetsBinding.instance.addPostFrameCallback((_) {
//       if (mounted) {
//         ScaffoldMessenger.of(
//           context,
//         ).showSnackBar(SnackBar(content: Text(message)));
//       }
//     });
//   }

//   Future<void> _selectMatchDate() async {
//     final picked = await showDatePicker(
//       context: context,
//       initialDate: DateTime.now(),
//       firstDate: DateTime(2000),
//       lastDate: DateTime(2100),
//     );
//     if (picked != null && mounted) {
//       setState(() {
//         _matchDateCtrl.text = DateFormat('dd/MM/yyyy').format(picked);
//       });
//     }
//   }

//   Future<void> _saveMatch() async {
//     if (!_formKey.currentState!.validate()) return;

//     // 1) parse the text to ints
//     final roundsVal = int.tryParse(_roundsCtrl.text.trim());
//     final roundTimeVal = int.tryParse(_roundTimeCtrl.text.trim());
//     final breakTimeVal = int.tryParse(_breakTimeCtrl.text.trim());

//     // 2) ensure they parsed
//     if (roundsVal == null || roundTimeVal == null || breakTimeVal == null) {
//       _showSnackBar('Please enter valid numbers for rounds/times.');
//       return;
//     }

//     // 3) range-checks
//     if (roundsVal < 1 || roundsVal > 15) {
//       _showSnackBar('Rounds must be between 1 and 15.');
//       return;
//     }
//     if (roundTimeVal < 1 || roundTimeVal > 20) {
//       _showSnackBar('Round time must be between 1 and 20 minutes.');
//       return;
//     }
//     if (breakTimeVal < 10 || breakTimeVal > 600) {
//       _showSnackBar('Break time must be between 10 and 600 seconds.');
//       return;
//     }

//     // 4) all clear—insert
//     try {
//       await _dbHelper.insertMatch(
//         matchName: _matchNameCtrl.text,
//         rounds: roundsVal,
//         matchDate: _matchDateCtrl.text,
//         roundTime: roundTimeVal,
//         breakTime: breakTimeVal,
//       );

//       if (!mounted) return;
//       _showSnackBar('Match added successfully.');

//       // ALWAYS refresh the matches list:
//       // ignore: unused_result
//       ref.refresh(matchesFutureProvider);

//       if (widget.onTabChange != null) {
//         // bottom-nav flow: switch to Games tab
//         widget.onTabChange!(1);
//       } else {
//         // pushed route flow: pop back
//         Navigator.of(context).pop();
//       }
//     } catch (e) {
//       if (!mounted) return;
//       _showSnackBar('Failed to add match: $e');
//     }
//   }

//   @override
//   Widget build(BuildContext context) {
//     final theme = Theme.of(context);

//     return PopScope(
//       canPop: true,
//       onPopInvokedWithResult: (didPop, result) {
//         if (!didPop) {
//           widget.onTabChange?.call(0);
//         }
//       },
//       child: Scaffold(
//         body: Container(
//           decoration: BoxDecoration(
//             gradient: LinearGradient(
//               colors: [
//                 theme.colorScheme.surface.withAlpha(5),
//                 theme.colorScheme.surface.withAlpha(8),
//               ],
//               begin: Alignment.topCenter,
//               end: Alignment.bottomCenter,
//             ),
//           ),
//           child: Column(
//             children: [
//               // DisplayRow(
//               //   title: 'Add New Game',
//               //   actions: [BackButton(color: theme.colorScheme.onSurface),
//               //   ],
//               // ),
//               DisplayRow(
//                 title: 'Games',
//                 actions: [
//                   IconButton(
//                     icon: Icon(
//                       Icons.arrow_back,
//                       color: theme.colorScheme.onSurface,
//                     ),
//                     onPressed: () {
//                       if (widget.onTabChange != null) {
//                         // we’re in the bottom-nav flow: just switch tabs
//                         widget.onTabChange!(0);
//                       } else {
//                         // we were pushed onto the Navigator stack: pop
//                         Navigator.of(context).pop();
//                       }
//                     },
//                   ),
//                 ],
//               ),

//               Expanded(
//                 child: Padding(
//                   padding: const EdgeInsets.fromLTRB(
//                     8,
//                     2,
//                     8,
//                     0,
//                   ), // const EdgeInsets.all(16),
//                   child: Form(
//                     key: _formKey,
//                     child: ListView(
//                       children: [
//                         MatchInfoCard(
//                           nameCtrl: _matchNameCtrl,
//                           dateCtrl: _matchDateCtrl,
//                           onDateTap: _selectMatchDate,
//                           roundsCtrl: _roundsCtrl,
//                           roundsValidator:
//                               (v) =>
//                                   v == null || v.isEmpty
//                                       ? 'Enter number of rounds'
//                                       : null,
//                           nameValidator:
//                               (v) =>
//                                   v == null || v.isEmpty
//                                       ? 'Enter a match name'
//                                       : null,
//                           dateValidator:
//                               (v) =>
//                                   v == null || v.isEmpty
//                                       ? 'Enter a date'
//                                       : null,
//                         ),
//                         TimingsCard(
//                           roundTimeCtrl: _roundTimeCtrl,
//                           breakTimeCtrl: _breakTimeCtrl,

//                           roundTimeValidator:
//                               (v) =>
//                                   v == null || v.isEmpty
//                                       ? 'Enter round time'
//                                       : null,
//                           breakTimeValidator:
//                               (v) =>
//                                   v == null || v.isEmpty
//                                       ? 'Enter break time'
//                                       : null,
//                         ),
//                         const SizedBox(height: 16),
//                         AddGameButton(onSave: _saveMatch),
//                       ],
//                     ),
//                   ),
//                 ),
//               ),
//             ],
//           ),
//         ),
//       ),
//     );
//   }
// }




// // // lib/screens/add_match_screen.dart
// import 'package:flutter/material.dart';
// import 'package:flutter_riverpod/flutter_riverpod.dart';
// import 'package:intl/intl.dart';
// import 'package:box_sensors/services/database_helper.dart';
// import 'package:box_sensors/services/providers.dart';
// import 'package:box_sensors/widgets/display_row.dart';
// import 'package:box_sensors/screens/match_info_card.dart';
// import 'package:box_sensors/screens/timings_card.dart';
// import 'package:box_sensors/screens/add_game_button.dart';
// import 'package:box_sensors/screens/matches_screen.dart';

// class AddMatchScreen extends ConsumerStatefulWidget {
//   const AddMatchScreen({super.key});

//   @override
//   ConsumerState<AddMatchScreen> createState() => _AddMatchScreenState();
// }

// class _AddMatchScreenState extends ConsumerState<AddMatchScreen> {
//   final _formKey = GlobalKey<FormState>();
//   late final DatabaseHelper _dbHelper;

//   final _matchNameCtrl = TextEditingController();
//   final _matchDateCtrl = TextEditingController();
//   final _roundsCtrl = TextEditingController();
//   final _roundTimeCtrl = TextEditingController();
//   final _breakTimeCtrl = TextEditingController();

//   String? _notEmpty(String? v) =>
//       (v == null || v.isEmpty) ? 'This field is required' : null;

//   @override
//   void initState() {
//     super.initState();
//     _dbHelper = ref.read(databaseHelperProvider);
//     _matchDateCtrl.text = DateFormat('dd/MM/yyyy').format(DateTime.now());
//   }

//   @override
//   void dispose() {
//     _matchNameCtrl.dispose();
//     _matchDateCtrl.dispose();
//     _roundsCtrl.dispose();
//     _roundTimeCtrl.dispose();
//     _breakTimeCtrl.dispose();
//     super.dispose();
//   }

//   /// Helper method to safely show a SnackBar.
//   void _showSnackBar(String message) {
//     WidgetsBinding.instance.addPostFrameCallback((_) {
//       if (mounted) {
//         ScaffoldMessenger.of(
//           context,
//         ).showSnackBar(SnackBar(content: Text(message)));
//       }
//     });
//   }

//   Future<void> _selectMatchDate() async {
//     final picked = await showDatePicker(
//       context: context,
//       initialDate: DateTime.now(),
//       firstDate: DateTime(2000),
//       lastDate: DateTime(2100),
//     );
//     if (picked != null && mounted) {
//       setState(() {
//         _matchDateCtrl.text = DateFormat('dd/MM/yyyy').format(picked);
//       });
//     }
//   }

//   Future<void> _saveMatch() async {
//     if (!_formKey.currentState!.validate()) return;

//     String rounds = _roundsCtrl.text.trim();
//     String roundTime = _roundTimeCtrl.text.trim();
//     String breakTime = _breakTimeCtrl.text.trim();

//     int? roundsCtrl = int.tryParse(rounds);


//     if (rounds < 1 || rounds > 15) {
//       _showSnackBar('Rounds must be between 1 and 15.');
//       return;
//     }

//     // if (roundTime < 1 || roundTime > 20) {
//     //   _showSnackBar('Round time must be between 1 and 20 minutes.');
//     //   return;
//     // }

//     // if (breakTime < 10 || breakTime > 600) {
//     //   _showSnackBar('Break time must be between 10 and 600 seconds.');
//     //   return;
//     // }

//     try {
//       await _dbHelper.insertMatch(
//         matchName: _matchNameCtrl.text,
//         rounds: int.parse(_roundsCtrl.text),
//         matchDate: _matchDateCtrl.text,
//         roundTime: int.parse(_roundTimeCtrl.text),
//         breakTime: int.parse(_breakTimeCtrl.text),
//       );

//       if (!mounted) return;
//       ScaffoldMessenger.of(context).showSnackBar(
//         const SnackBar(content: Text('Match added successfully.')),
//       );
//       Navigator.pushReplacement(
//         context,
//         MaterialPageRoute(builder: (_) => const MatchesScreen()),
//       );
//     } catch (e) {
//       if (!mounted) return;
//       ScaffoldMessenger.of(
//         context,
//       ).showSnackBar(SnackBar(content: Text('Failed to add match: $e')));
//     }
//   }

//   @override
//   Widget build(BuildContext context) {
//     final theme = Theme.of(context);
//     return Scaffold(
//       body: Container(
//         decoration: BoxDecoration(
//           gradient: LinearGradient(
//             colors: [
//               theme.colorScheme.surface.withAlpha(5),
//               theme.colorScheme.surface.withAlpha(8),
//             ],
//             begin: Alignment.topCenter,
//             end: Alignment.bottomCenter,
//           ),
//         ),
//         child: Column(
//           children: [
//             DisplayRow(
//               title: 'Add New Game',
//               actions: [BackButton(color: theme.colorScheme.onSurface)],
//             ),

//             // the form goes inside Expanded so it scrolls if needed
//             Expanded(
//               child: Padding(
//                 padding: const EdgeInsets.all(16),
//                 child: Form(
//                   key: _formKey,
//                   child: ListView(
//                     children: [
//                       MatchInfoCard(
//                         nameCtrl: _matchNameCtrl,
//                         dateCtrl: _matchDateCtrl,
//                         roundsCtrl: _roundsCtrl,
//                         onDateTap: _selectMatchDate,
//                         nameValidator: _notEmpty,
//                         dateValidator: _notEmpty,
//                         roundsValidator: _notEmpty,
//                       ),
//                       TimingsCard(
//                         roundTimeCtrl: _roundTimeCtrl,
//                         breakTimeCtrl: _breakTimeCtrl,
//                         roundTimeValidator: (v) {
//                           if (v == null || v.isEmpty) return 'Enter a time';
//                           if (int.tryParse(v) == null)
//                             return 'Must be a number';
//                           return null;
//                         },
//                         breakTimeValidator: (v) {
//                           if (v == null || v.isEmpty) return 'Enter a break';
//                           if (int.tryParse(v) == null)
//                             return 'Must be a number';
//                           return null;
//                         },
//                       ),
//                       const SizedBox(height: 16),
//                       AddGameButton(onSave: _saveMatch),
//                     ],
//                   ),
//                 ),
//               ),
//             ),
//           ],
//         ),
//       ),
//     );
//   }
// }






// // lib/screens/add_match_screen.dart
// import 'package:box_sensors/widgets/display_row.dart';
// import 'package:flutter/material.dart';
// import 'package:box_sensors/services/database_helper.dart';
// import 'package:box_sensors/services/providers.dart';
// import 'package:box_sensors/widgets/custom_text_form_field.dart';
// import 'package:intl/intl.dart';
// import 'package:box_sensors/screens/matches_screen.dart';
// import 'package:flutter_riverpod/flutter_riverpod.dart';

// class AddMatchScreen extends ConsumerStatefulWidget {
//   const AddMatchScreen({super.key});

//   @override
//   ConsumerState<AddMatchScreen> createState() => _AddMatchScreenState();
// }

// class _AddMatchScreenState extends ConsumerState<AddMatchScreen> {
//   final _formKey = GlobalKey<FormState>();
//   // Instead of creating a new instance here, get it from the provider.
//   late final DatabaseHelper dbHelper;

//   // Text controllers for input fields.
//   final TextEditingController matchNameController = TextEditingController();
//   final TextEditingController matchDateController = TextEditingController();
//   final TextEditingController roundsController = TextEditingController();
//   final TextEditingController finishedAtRoundController = TextEditingController();
//   final TextEditingController roundTimeController = TextEditingController();
//   final TextEditingController breakTimeController = TextEditingController();

//   bool _disposed = false;

//   /// Helper method to safely call setState if the widget is still mounted.
//   void _safeSetState(VoidCallback fn) {
//     if (!_disposed && mounted) {
//       setState(fn);
//     }
//   }

//   @override
//   void initState() {
//     super.initState();
//     // Get the DatabaseHelper from Riverpod.
//     dbHelper = ref.read(databaseHelperProvider);

//     // Automatically set today's date in dd/MM/yyyy format.
//     matchDateController.text = DateFormat('dd/MM/yyyy').format(DateTime.now());
//   }

//   @override
//   void dispose() {
//     _disposed = true;
//     matchNameController.dispose();
//     matchDateController.dispose();
//     roundsController.dispose();
//     finishedAtRoundController.dispose();
//     roundTimeController.dispose();
//     breakTimeController.dispose();
//     super.dispose();
//   }

//   Future<void> _saveMatch() async {
//     if (_formKey.currentState!.validate()) {
//       try {
//         await dbHelper.insertMatch(
//           matchName: matchNameController.text,
//           rounds: int.parse(roundsController.text),
//           matchDate: matchDateController.text,
//           roundTime: int.parse(roundTimeController.text),
//           breakTime: int.parse(breakTimeController.text),
//         );
//         if (!mounted) return;
//         // Show a success SnackBar.
//         ScaffoldMessenger.of(context).showSnackBar(
//           const SnackBar(content: Text('Match added successfully.')),
//         );
//         // Navigate to MatchesScreen.
//         Navigator.pushReplacement(
//           context,
//           MaterialPageRoute(builder: (_) => const MatchesScreen()),
//         );
//       } catch (e) {
//         if (!mounted) return;
//         // Show a failure SnackBar.
//         ScaffoldMessenger.of(context).showSnackBar(
//           const SnackBar(content: Text('Failed to add match.')),
//         );
//       }
//     }
//   }

//   /// Opens a date picker to select a match date.
//   Future<void> _selectMatchDate() async {
//     DateTime? pickedDate = await showDatePicker(
//       context: context,
//       initialDate: DateTime.now(),
//       firstDate: DateTime(2000),
//       lastDate: DateTime(2100),
//     );
//     if (pickedDate != null) {
//       _safeSetState(() {
//         matchDateController.text = DateFormat('dd/MM/yyyy').format(pickedDate);
//       });
//     }
//   }

//   @override
//   Widget build(BuildContext context) {
//     final theme = Theme.of(context);
//     return Scaffold(
//       // Wrap the content in a Container with a gradient background.
//       body: Container(
//         decoration: BoxDecoration(
//           gradient: LinearGradient(
//             colors: [
//               theme.colorScheme.surface.withAlpha(5),
//               theme.colorScheme.surface.withAlpha(8),
//             ],
//             begin: Alignment.topCenter,
//             end: Alignment.bottomCenter,
//           ),
//         ),
//         child: Column(
//           children: [
//             DisplayRow(
//               title: 'Add New Game',
//               actions: [
//                 IconButton(
//                   icon: Icon(
//                     Icons.arrow_back,
//                     color: theme.colorScheme.onSurface,
//                   ),
//                   onPressed: () {
//                     Navigator.pop(context);
//                   },
//                 ),
//               ],
//             ),
//             Expanded(
//               child: Padding(
//                 padding: const EdgeInsets.all(16.0),
//                 child: Form(
//                   key: _formKey,
//                   child: ListView(
//                     children: [
//                       Card(
//                         margin: const EdgeInsets.symmetric(vertical: 8),
//                         color: theme.cardColor,
//                         elevation: 6,
//                         shape: RoundedRectangleBorder(
//                           borderRadius: BorderRadius.circular(12),
//                           side: BorderSide(
//                             color: theme.colorScheme.outline,
//                             width: 1,
//                           ),
//                         ),
//                         child: Padding(
//                           padding: const EdgeInsets.all(8.0),
//                           child: Column(
//                             crossAxisAlignment: CrossAxisAlignment.start,
//                             children: [
//                               Text(
//                                 'Match Info',
//                                 style: TextStyle(
//                                   fontSize: 16,
//                                   fontWeight: FontWeight.bold,
//                                   color: theme.colorScheme.primary,
//                                 ),
//                               ),
//                               const SizedBox(height: 8),
//                               // Match Name
//                               CustomTextFormField(
//                                 controller: matchNameController,
//                                 label: 'Match Name',
//                                 validator: (value) {
//                                   if (value == null || value.isEmpty) {
//                                     return 'Please enter a match name';
//                                   }
//                                   return null;
//                                 },
//                               ),
//                               const SizedBox(height: 16),
//                               // Match Date with date picker.
//                               GestureDetector(
//                                 onTap: _selectMatchDate,
//                                 child: AbsorbPointer(
//                                   child: TextFormField(
//                                     controller: matchDateController,
//                                     decoration: InputDecoration(
//                                       border: const OutlineInputBorder(),
//                                       filled: true,
//                                       fillColor: theme.colorScheme.surface,
//                                       labelText: 'Match Date (DD/MM/YYYY)',
//                                       labelStyle: const TextStyle(fontWeight: FontWeight.bold),
//                                       suffixIcon: const Icon(Icons.calendar_today),
//                                       isDense: true,
//                                       contentPadding: const EdgeInsets.symmetric(
//                                         vertical: 12,
//                                         horizontal: 10,
//                                       ),
//                                       floatingLabelBehavior: FloatingLabelBehavior.always,
//                                     ),
//                                     style: const TextStyle(fontSize: 14),
//                                   ),
//                                 ),
//                               ),
//                               const SizedBox(height: 16),
//                               // Rounds.
//                               CustomTextFormField(
//                                 controller: roundsController,
//                                 label: 'Rounds',
//                                 keyboardType: TextInputType.number,
//                                 validator: (value) {
//                                   if (value == null || value.isEmpty) {
//                                     return 'Please enter the number of rounds';
//                                   }
//                                   return null;
//                                 },
//                               ),
//                             ],
//                           ),
//                         ),
//                       ),
//                       Card(
//                         margin: const EdgeInsets.symmetric(vertical: 8),
//                         color: theme.cardColor,
//                         elevation: 6,
//                         shape: RoundedRectangleBorder(
//                           borderRadius: BorderRadius.circular(12),
//                           side: BorderSide(
//                             color: theme.colorScheme.outline,
//                             width: 1,
//                           ),
//                         ),
//                         child: Padding(
//                           padding: const EdgeInsets.all(8.0),
//                           child: Column(
//                             crossAxisAlignment: CrossAxisAlignment.start,
//                             children: [
//                               Text(
//                                 'Timings',
//                                 style: TextStyle(
//                                   fontSize: 16,
//                                   fontWeight: FontWeight.bold,
//                                   color: theme.colorScheme.primary,
//                                 ),
//                               ),
//                               const SizedBox(height: 8),
//                               // Round Time.
//                               CustomTextFormField(
//                                 controller: roundTimeController,
//                                 label: 'Round Time (in minutes)',
//                                 keyboardType: TextInputType.number,
//                                 validator: (value) {
//                                   if (value == null || value.isEmpty) {
//                                     return 'Please enter the round time in minutes';
//                                   }
//                                   return null;
//                                 },
//                               ),
//                               const SizedBox(height: 16),
//                               // Break Time.
//                               CustomTextFormField(
//                                 controller: breakTimeController,
//                                 label: 'Break Time (in seconds)',
//                                 keyboardType: TextInputType.number,
//                                 validator: (value) {
//                                   if (value == null || value.isEmpty) {
//                                     return 'Please enter the break time in seconds';
//                                   }
//                                   return null;
//                                 },
//                               ),
//                             ],
//                           ),
//                         ),
//                       ),
//                       const SizedBox(height: 6),
//                       ElevatedButton(
//                         onPressed: _saveMatch,
//                         style: ElevatedButton.styleFrom(
//                           backgroundColor: theme.colorScheme.primary,
//                           foregroundColor: theme.colorScheme.onPrimary,
//                           elevation: 6,
//                           shadowColor: theme.shadowColor,
//                           surfaceTintColor: theme.colorScheme.primaryContainer,
//                           fixedSize: const Size.fromHeight(40),
//                         ),
//                         child: Text(
//                           'Add Game',
//                           style: TextStyle(
//                             color: theme.colorScheme.onPrimary,
//                             fontWeight: FontWeight.bold,
//                           ),
//                         ),
//                       ),
//                     ],
//                   ),
//                 ),
//               ),
//             ),
//           ],
//         ),
//       ),
//     );
//   }
// }



