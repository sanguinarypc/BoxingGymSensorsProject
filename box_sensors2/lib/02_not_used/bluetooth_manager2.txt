// // // -------------------------------------------------------------------------------------------------------
// // // // CODE 0  flutter_reactive_ble   flutter_reactive_ble: ^5.4.0
// // ignore_for_file: deprecated_member_use, discoverServices
// import 'dart:async';
// import 'dart:collection';
// import 'dart:convert';
// import 'dart:io' show Platform;
// import 'package:flutter/foundation.dart' show kIsWeb;
// import 'package:flutter/material.dart';
// import 'package:flutter_reactive_ble/flutter_reactive_ble.dart';
// import 'package:sentry_flutter/sentry_flutter.dart';
// import 'package:box_sensors/state/timer_state.dart';
// import 'package:box_sensors/services/database_helper.dart';

// class BluetoothManager with ChangeNotifier {
//   // Reactive BLE instance.
//   final FlutterReactiveBle _ble = FlutterReactiveBle();

//   TimerState? _timerState;
//   int? _currentRoundId;
//   int? _currentMatchId;
//   bool _disposed = false;
//   bool _manualDisconnect = false;

//   // Streams for table rows and disconnection events.
//   final StreamController<List<DataRow>> _messageStreamController =
//       StreamController<List<DataRow>>.broadcast();
//   final StreamController<String?> _disconnectionStreamController =
//       StreamController<String?>.broadcast();

//   // Connected devices map.
//   final Map<String, bool> connectedDevices = {
//     'BlueBoxer': false,
//     'RedBoxer': false,
//     'BoxerServer': false,
//   };
//   final Map<String, String> connectedDeviceIds = {
//     'BlueBoxer': '',
//     'RedBoxer': '',
//     'BoxerServer': '',
//   };

//   // ‚úÖ NEW: Reactive ValueNotifier for connection status.
//   final ValueNotifier<Map<String, bool>> connectedDevicesNotifier =
//       ValueNotifier<Map<String, bool>>({
//         'BlueBoxer': false,
//         'RedBoxer': false,
//         'BoxerServer': false,
//       });

//   // ‚úÖ NEW: RSSI notifier for connected devices
//   final Map<String, ValueNotifier<int>> deviceRssiNotifier = {
//     'BlueBoxer': ValueNotifier<int>(-100),
//     'RedBoxer': ValueNotifier<int>(-100),
//     'BoxerServer': ValueNotifier<int>(-100),
//   };

//   // Connection & notification subscriptions.
//   final Map<String, StreamSubscription<ConnectionStateUpdate>>
//   _connectionSubscriptions = {};
//   final Map<String, StreamSubscription<List<int>>> _notificationSubscriptions =
//       {};

//   // Optional writable characteristic.
//   QualifiedCharacteristic? writableCharacteristic;

//   // Data table rows and database.
//   List<DataRow> rows = [];
//   final DatabaseHelper dbHelper = DatabaseHelper();

//   // Getters.
//   Stream<List<DataRow>> get messageStream => _messageStreamController.stream;
//   Stream<String?> get disconnectionStream =>
//       _disconnectionStreamController.stream;
//   int? get currentRoundId => _currentRoundId;
//   int? get currentMatchId => _currentMatchId;
//   bool get isConnectedDevice1 => connectedDevices['BlueBoxer'] ?? false;
//   bool get isConnectedDevice2 => connectedDevices['RedBoxer'] ?? false;
//   bool get isConnectedDevice3 => connectedDevices['BoxerServer'] ?? false;

//   /// Returns a device key using the discovered device‚Äôs name or its id.
//   String getDeviceKey(DiscoveredDevice device) {
//     final name = device.name.trim();
//     return name.isEmpty || name.toLowerCase() == 'unknown' ? device.id : name;
//   }

//   /// Inject TimerState.
//   void setTimerState(TimerState timerState) {
//     debugPrint('setTimerState(...) called with timerState=$timerState');
//     _timerState = timerState;
//   }

//   void setCurrentRoundId(int roundId) {
//     _currentRoundId = roundId;
//     _safeNotifyListeners();
//   }

//   void setCurrentMatchId(int? matchId) {
//     _currentMatchId = matchId;
//     _safeNotifyListeners();
//   }

//   /// Clear the in-memory table.
//   void clearTable() {
//     if (rows.isEmpty) {
//       debugPrint("Table is already clear.");
//       return;
//     }
//     rows.clear();
//     if (!_messageStreamController.isClosed) {
//       _messageStreamController.add([]);
//     }
//     _safeNotifyListeners();
//   }

//   /// Discover services and subscribe to notifiable characteristics.
//   Future<void> discoverServices(String deviceKey, String deviceId) async {
//     debugPrint("üîç Discovering services for device: $deviceKey");
//     try {
//       final List<DiscoveredService> services = await _ble.discoverServices(
//         deviceId,
//       );
//       for (final service in services) {
//         for (final characteristic in service.characteristics) {
//           if (characteristic.isNotifiable || characteristic.isIndicatable) {
//             final subKey = '$deviceKey-${characteristic.characteristicId}';
//             if (_notificationSubscriptions.containsKey(subKey)) {
//               debugPrint("‚ö†Ô∏è Already subscribed to $subKey, skipping.");
//               continue;
//             }
//             debugPrint(
//               "‚úÖ Subscribing to characteristic ${characteristic.characteristicId} for $deviceKey.",
//             );
//             final qualified = QualifiedCharacteristic(
//               deviceId: deviceId,
//               serviceId: service.serviceId,
//               characteristicId: characteristic.characteristicId,
//             );
//             final subscription = _ble
//                 .subscribeToCharacteristic(qualified)
//                 .listen(
//                   (data) => _handleNotification(data, deviceKey),
//                   onError: (error, stackTrace) {
//                     debugPrint(
//                       "‚ùå Error in notification stream for $deviceKey: $error",
//                     );
//                     Sentry.captureException(error, stackTrace: stackTrace);
//                   },
//                 );
//             _notificationSubscriptions[subKey] = subscription;
//           }
//         }
//       }
//     } catch (e, stackTrace) {
//       debugPrint("‚ùå Error discovering services for $deviceKey: $e");
//       Sentry.captureException(e, stackTrace: stackTrace);
//     }
//   }

//   /// Process incoming notifications.
//   ///
//   /// This method first tries to decode JSON; if that fails, it falls back to regex extraction.
//   /// After extraction, it checks if the timestamp or sensor value (or punchCount) are missing.
//   /// If any of these values are missing (i.e. using default values), it skips adding the row.
//   void _handleNotification(List<int> value, String deviceKey) async {
//     if (_disposed) return;
//     try {
//       final decodedMessage = utf8.decode(value);
//       debugPrint("üì© Received notification from $deviceKey: $decodedMessage");

//       String? punchCount;
//       String? timestamp;
//       String? sensorValue;

//       // Try JSON decode.
//       dynamic parsed;
//       try {
//         parsed = json.decode(decodedMessage);
//       } catch (_) {
//         // Not JSON.
//       }
//       if (parsed is Map<String, dynamic>) {
//         if (parsed.containsKey("PunchCount")) {
//           punchCount = parsed["PunchCount"].toString();
//         }
//         if (parsed.containsKey("Timestamp")) {
//           timestamp = parsed["Timestamp"].toString();
//         }
//         if (parsed.containsKey("Sensor")) {
//           sensorValue = parsed["Sensor"].toString();
//         } else if (parsed.containsKey("Sensor millivolts")) {
//           sensorValue = parsed["Sensor millivolts"].toString();
//         }
//         if (parsed["RoundState"] == "Completed") {
//           _timerState
//               ?.endMatch(); // End the match. very important to check other things here.
//         }
//       }

//       // Fallback to regex extraction if JSON did not provide values.
//       punchCount ??= _extractPunchCount(decodedMessage);
//       timestamp ??= _extractTimestamp(decodedMessage);
//       sensorValue ??= _extractSensorValue(decodedMessage);

//       // Use default values if still missing.
//       punchCount = punchCount ?? "N/A";
//       timestamp = timestamp ?? "";
//       sensorValue = sensorValue ?? "";

//       // ***** NEW: If any of the key fields are missing, skip this notification.
//       if (punchCount == "N/A" || timestamp.isEmpty || sensorValue.isEmpty) {
//         debugPrint(
//           "Skipping notification due to missing sensor data: PunchCount=$punchCount, Timestamp='$timestamp', Sensor='$sensorValue'",
//         );
//         return;
//       }

//       // Determine device name.
//       String deviceFromMessage = _extractDevice(decodedMessage);
//       if (deviceFromMessage == "UnknownDevice") {
//         deviceFromMessage = deviceKey;
//       }

//       // Create a new row.
//       final newRow = DataRow(
//         cells: [
//           DataCell(Center(child: Text(deviceFromMessage))),
//           DataCell(
//             Center(
//               child: Text(
//                 deviceFromMessage == "BlueBoxer" ? "RedBoxer" : "BlueBoxer",
//               ),
//             ),
//           ),
//           DataCell(Center(child: Text(punchCount))),
//           DataCell(Center(child: Text(timestamp))),
//           DataCell(Center(child: Text(sensorValue))),
//         ],
//       );
//       rows.add(newRow);
//       _messageStreamController.add(List.from(rows));
//       _safeNotifyListeners();

//       // Insert data into the database.
//       final localRoundId = _currentRoundId;
//       final localMatchId = _currentMatchId;
//       if (localMatchId == null) {
//         _sendDataAndInsertToDatabase(
//           deviceFromMessage,
//           (deviceFromMessage == "BlueBoxer") ? "RedBoxer" : "BlueBoxer",
//           punchCount,
//           timestamp,
//           sensorValue,
//           0,
//           null,
//         );
//       } else {
//         _sendDataAndInsertToDatabase(
//           deviceFromMessage,
//           (deviceFromMessage == "BlueBoxer") ? "RedBoxer" : "BlueBoxer",
//           punchCount,
//           timestamp,
//           sensorValue,
//           localRoundId ?? 0,
//           localMatchId,
//         );
//       }
//     } catch (e, stackTrace) {
//       if (!_disposed) {
//         debugPrint("‚ùå Error processing notification from $deviceKey: $e");
//         Sentry.captureException(e, stackTrace: stackTrace);
//       }
//     }
//   }

//   // --- REGEX patterns for fallback extraction ---
//   static final RegExp _deviceRegex = RegExp(r'Device:\s*(\S+)');
//   static final RegExp _punchCountRegex = RegExp(r'Punch Count:\s*([\d:]+)');
//   static final RegExp _timestampRegex = RegExp(r'Timestamp:\s*([\d:]+)');
//   static final RegExp _sensorValueRegex = RegExp(r'Sensor millivolts:\s*(\d+)');

//   String _extractDevice(String message) =>
//       _extractValue(message, _deviceRegex) ?? "UnknownDevice";
//   String? _extractPunchCount(String message) =>
//       _extractValue(message, _punchCountRegex);
//   String? _extractTimestamp(String message) =>
//       _extractValue(message, _timestampRegex);
//   String? _extractSensorValue(String message) =>
//       _extractValue(message, _sensorValueRegex);

//   String? _extractValue(String message, RegExp regex) {
//     final match = regex.firstMatch(message);
//     return match?.group(1);
//   }

//   /// Send a text message to all connected devices.
//   Future<void> sendMessageToAllConnectedDevices(String message) async {
//     final trimmedMessage = message.trim();
//     if (trimmedMessage.isEmpty || trimmedMessage == "[]") {
//       debugPrint("Refusing to send empty/bracket message.");
//       return;
//     }
//     final futures = <Future<void>>[];
//     for (final deviceKey in connectedDevices.keys) {
//       final deviceId = connectedDeviceIds[deviceKey] ?? '';
//       if (deviceId.isNotEmpty) {
//         futures.add(
//           _sendMessageToDevice(deviceKey, deviceId, trimmedMessage).catchError((
//             e,
//             stackTrace,
//           ) {
//             debugPrint("Error sending message to $deviceKey: $e");
//             Sentry.captureException(e, stackTrace: stackTrace);
//           }),
//         );
//       }
//     }
//     if (futures.isEmpty) {
//       debugPrint("No connected devices to send the message.");
//       return;
//     }
//     await Future.wait(futures);
//   }

//   /// Helper to discover a writable characteristic and send a message.
//   Future<void> _sendMessageToDevice(
//     String deviceKey,
//     String deviceId,
//     String message,
//   ) async {
//     try {
//       final services = await _ble.discoverServices(deviceId);
//       final List<Future<void>> writeFutures = [];
//       for (final service in services) {
//         for (final characteristic in service.characteristics) {
//           if (characteristic.isWritableWithResponse ||
//               characteristic.isWritableWithoutResponse) {
//             debugPrint(
//               "Found writable characteristic ${characteristic.characteristicId} on $deviceKey",
//             );
//             final qualified = QualifiedCharacteristic(
//               deviceId: deviceId,
//               serviceId: service.serviceId,
//               characteristicId: characteristic.characteristicId,
//             );
//             writeFutures.add(
//               _ble
//                   .writeCharacteristicWithResponse(
//                     qualified,
//                     value: utf8.encode(message),
//                   )
//                   .then((_) {
//                     debugPrint(
//                       "Message sent to $deviceKey via ${characteristic.characteristicId}: $message",
//                     );
//                   })
//                   .catchError((error, stackTrace) {
//                     debugPrint(
//                       "Error sending message via ${characteristic.characteristicId} on $deviceKey: $error",
//                     );
//                     Sentry.captureException(error, stackTrace: stackTrace);
//                   }),
//             );
//           }
//         }
//       }
//       if (writeFutures.isEmpty) {
//         debugPrint("No writable characteristics found on $deviceKey.");
//       } else {
//         await Future.wait(writeFutures);
//       }
//     } catch (e, stackTrace) {
//       debugPrint("Error in _sendMessageToDevice for $deviceKey: $e");
//       Sentry.captureException(e, stackTrace: stackTrace);
//     }
//   }

//   /// A simpler single-device send.
//   Future<void> sendMessageToConnectedDevice(String message) async {
//     final trimmedMessage = message.trim();
//     if (trimmedMessage.isEmpty || trimmedMessage == "[]") {
//       debugPrint("Refusing to send empty/bracket message.");
//       return;
//     }
//     if (writableCharacteristic != null) {
//       try {
//         await _ble.writeCharacteristicWithResponse(
//           writableCharacteristic!,
//           value: utf8.encode(trimmedMessage),
//         );
//         debugPrint("Message sent via cached characteristic: $trimmedMessage");
//         return;
//       } catch (e, stackTrace) {
//         debugPrint("Error sending message via cached characteristic: $e");
//         Sentry.captureException(e, stackTrace: stackTrace);
//         debugPrint("Falling back to service discovery.");
//       }
//     }
//     final fallbackEntry = connectedDeviceIds.entries.firstWhere(
//       (entry) => entry.value.isNotEmpty,
//       orElse: () => const MapEntry("", ""),
//     );
//     if (fallbackEntry.key.isEmpty) {
//       debugPrint("No connected devices available for fallback.");
//       return;
//     }
//     await _sendMessageToDevice(
//       fallbackEntry.key,
//       fallbackEntry.value,
//       trimmedMessage,
//     );
//   }

//   /// Sends JSON-formatted data to BoxerServer.
//   Future<void> sendDataToBoxerServer({
//     required String deviceStr,
//     required String oppositeDevice,
//     required String punchCount,
//     required String timestamp,
//     required String sensorValue,
//   }) async {
//     final dataMap = {
//       "deviceStr": deviceStr,
//       "oppositeDevice": oppositeDevice,
//       "punchCount": punchCount,
//       "timestamp": timestamp,
//       "sensorValue": sensorValue,
//     };
//     final dataMessage = jsonEncode(dataMap);
//     debugPrint("Sending data to BoxerServer (JSON): $dataMessage");

//     final boxerServerId = connectedDeviceIds["BoxerServer"] ?? '';
//     if (boxerServerId.isEmpty) {
//       debugPrint("BoxerServer is not connected. Cannot send data.");
//       return;
//     }
//     try {
//       await _sendMessageToDevice("BoxerServer", boxerServerId, dataMessage);
//       debugPrint("Data sent to BoxerServer successfully.");
//     } catch (e, stackTrace) {
//       debugPrint("Error sending data to BoxerServer: $e");
//       Sentry.captureException(e, stackTrace: stackTrace);
//     }
//   }

//   /// Insert into DB and send data concurrently.
//   void _sendDataAndInsertToDatabase(
//     String deviceStr,
//     String oppositeDevice,
//     String punchCount,
//     String timestamp,
//     String sensorValue,
//     int roundId,
//     int? matchId,
//   ) {
//     if (matchId != null) {
//       Future.wait([
//         _sendDataToBoxerServer(
//           deviceStr,
//           oppositeDevice,
//           punchCount,
//           timestamp,
//           sensorValue,
//         ),
//         _insertDataToDatabase(
//           deviceStr,
//           oppositeDevice,
//           punchCount,
//           timestamp,
//           sensorValue,
//           roundId,
//           matchId,
//         ),
//       ]);
//     } else {
//       Future.wait([
//         _sendDataToBoxerServer(
//           deviceStr,
//           oppositeDevice,
//           punchCount,
//           timestamp,
//           sensorValue,
//         ),
//         _insertTrainingDataToDatabase(
//           deviceStr,
//           oppositeDevice,
//           punchCount,
//           timestamp,
//           sensorValue,
//         ),
//       ]);
//     }
//   }

//   Future<void> _insertDataToDatabase(
//     String deviceStr,
//     String oppositeDevice,
//     String punchCount,
//     String timestamp,
//     String sensorValue,
//     int roundId,
//     int matchId,
//   ) async {
//     try {
//       await dbHelper.insertMessage(
//         deviceStr,
//         oppositeDevice,
//         punchCount,
//         timestamp,
//         sensorValue,
//         roundId,
//         matchId,
//       );
//     } catch (e, stackTrace) {
//       debugPrint("‚ùå Error inserting message into DB: $e");
//       Sentry.captureException(e, stackTrace: stackTrace);
//     }
//   }

//   Future<void> _insertTrainingDataToDatabase(
//     String deviceStr,
//     String oppositeDevice,
//     String punchCount,
//     String timestamp,
//     String sensorValue,
//   ) async {
//     try {
//       await dbHelper.insertTrainingData(
//         deviceStr,
//         oppositeDevice,
//         punchCount,
//         timestamp,
//         sensorValue,
//       );
//     } catch (e, stackTrace) {
//       debugPrint("‚ùå Error inserting training data into DB: $e");
//       Sentry.captureException(e, stackTrace: stackTrace);
//     }
//   }

//   /// Helper to send data to BoxerServer.
//   Future<void> _sendDataToBoxerServer(
//     String deviceStr,
//     String oppositeDevice,
//     String punchCount,
//     String timestamp,
//     String sensorValue,
//   ) async {
//     if (!isDeviceConnected("BoxerServer")) {
//       debugPrint("‚ùå BoxerServer not connected. Skipping data send.");
//       return;
//     }
//     try {
//       await sendDataToBoxerServer(
//         deviceStr: deviceStr,
//         oppositeDevice: oppositeDevice,
//         punchCount: punchCount,
//         timestamp: timestamp,
//         sensorValue: sensorValue,
//       );
//     } catch (e, stackTrace) {
//       debugPrint("‚ùå Error sending data to BoxerServer: $e");
//       Sentry.captureException(e, stackTrace: stackTrace);
//     }
//   }

//   /// Connect to a device (with optional MTU request on Android).
//   Future<void> connectToDevice(DiscoveredDevice device) async {
//     final deviceKey = getDeviceKey(device);
//     if (connectedDeviceIds[deviceKey]?.isNotEmpty ?? false) {
//       debugPrint("Device $deviceKey is already connected.");
//       return;
//     }

//     _manualDisconnect = false;
//     try {
//       final connectionStream = _ble.connectToDevice(
//         id: device.id,
//         connectionTimeout: const Duration(seconds: 5),
//       );

//       final subscription = connectionStream.listen(
//         (update) async {
//           debugPrint(
//             "Connection update for $deviceKey: ${update.connectionState}",
//           );

//           if (update.connectionState == DeviceConnectionState.connected) {
//             connectedDeviceIds[deviceKey] = device.id;
//             _updateDeviceConnectionStatus(deviceKey, true);
//             _safeNotifyListeners();

//             if (Platform.isAndroid) {
//               try {
//                 final newMtu = await _ble.requestMtu(
//                   deviceId: device.id,
//                   mtu: 247,
//                 );
//                 debugPrint("MTU set to $newMtu for $deviceKey");
//               } catch (mtuError, st) {
//                 debugPrint("Error requesting MTU: $mtuError");
//                 Sentry.captureException(mtuError, stackTrace: st);
//               }
//             }

//             await discoverServices(deviceKey, device.id);
//           } else if (update.connectionState ==
//               DeviceConnectionState.disconnected) {
//             _updateDeviceConnectionStatus(deviceKey, false);
//             connectedDeviceIds[deviceKey] = '';
//             _disconnectionStreamController.add(deviceKey);
//             await _connectionSubscriptions[deviceKey]?.cancel();
//             _connectionSubscriptions.remove(deviceKey);
//             _safeNotifyListeners();

//             if (!_manualDisconnect) {
//               Future.delayed(const Duration(seconds: 3), () {
//                 if (!_disposed) {
//                   debugPrint("Attempting to reconnect to $deviceKey...");
//                   connectToDevice(device);
//                 }
//               });
//             }
//           }
//         },
//         onError: (error, stackTrace) {
//           debugPrint("‚ùå Error in connection stream for $deviceKey: $error");
//           Sentry.captureException(error, stackTrace: stackTrace);
//         },
//       );

//       _connectionSubscriptions[deviceKey] = subscription;
//     } catch (e, stackTrace) {
//       debugPrint("Error connecting to device $deviceKey: $e");
//       _updateDeviceConnectionStatus(deviceKey, false);
//       _safeNotifyListeners();
//       Sentry.captureException(e, stackTrace: stackTrace);
//     }
//   }

//   Future<void> disconnectDeviceByName(String deviceKey) async {
//     await _disconnectDevice(deviceKey);
//   }

//   /// Disconnect from all devices.
//   Future<void> disconnectFromDevice() async {
//     _manualDisconnect = true;
//     final futures = <Future<void>>[];
//     for (final deviceKey in connectedDevices.keys) {
//       final deviceId = connectedDeviceIds[deviceKey] ?? '';
//       if (deviceId.isNotEmpty) {
//         futures.add(_disconnectDevice(deviceKey));
//       }
//     }
//     await Future.wait(futures);
//     _safeNotifyListeners();
//   }

//   Future<void> _disconnectDevice(String deviceKey) async {
//     try {
//       await _connectionSubscriptions[deviceKey]?.cancel();
//       _connectionSubscriptions.remove(deviceKey);
//       _notificationSubscriptions.removeWhere(
//         (key, _) => key.startsWith(deviceKey),
//       );
//       connectedDeviceIds[deviceKey] = '';
//       _updateDeviceConnectionStatus(deviceKey, false);
//       _disconnectionStreamController.add(deviceKey);
//     } catch (e, stackTrace) {
//       debugPrint("Error disconnecting from device $deviceKey: $e");
//       Sentry.captureException(e, stackTrace: stackTrace);
//     }
//   }

//   // ‚úÖ Modified _updateDeviceConnectionStatus to update both connectedDevices and the notifier,
//   // then notify listeners so that UI (which reads connectedDevices) is refreshed.
//   void _updateDeviceConnectionStatus(String deviceKey, bool status) {
//     if (!connectedDevices.containsKey(deviceKey)) {
//       debugPrint("Warning: $deviceKey not in connectedDevices map.");
//       return;
//     }
//     if (connectedDevices[deviceKey] != status) {
//       connectedDevices[deviceKey] = status;
//       connectedDevicesNotifier.value = {
//         ...connectedDevicesNotifier.value,
//         deviceKey: status,
//       };
//       debugPrint('$deviceKey connection status updated to: $status');
//       _safeNotifyListeners();
//     }
//   }

//   bool isDeviceConnected(String deviceKey) =>
//       connectedDevices[deviceKey] ?? false;

//   /// Basic scan for devices.
//   Future<void> scanForDevices({List<Uuid>? withServices}) async {
//     if (kIsWeb || !(Platform.isAndroid || Platform.isIOS)) {
//       debugPrint("BLE scanning not supported on this platform.");
//       return;
//     }
//     debugPrint("Starting BLE scan...");
//     try {
//       _ble
//           .scanForDevices(
//             withServices: withServices ?? [],
//             scanMode: ScanMode.lowLatency,
//           )
//           .listen(
//             (device) {
//               debugPrint("Found device: ${device.name} (${device.id})");
//             },
//             onError: (error) {
//               debugPrint("Error during scan: $error");
//               Sentry.captureException(error);
//             },
//           );
//     } catch (e, stackTrace) {
//       debugPrint("Scan error: $e");
//       Sentry.captureException(e, stackTrace: stackTrace);
//     }
//   }

//   /// Return a read-only view of unique messages (empty for now).
//   Set<String> getUniqueMessages() {
//     return UnmodifiableSetView({});
//   }

//   void _safeNotifyListeners() {
//     if (!_disposed) {
//       notifyListeners();
//     }
//   }

//   // ‚úÖ Corrected RSSI getter method
//   int getRssi(String deviceKey) {
//     return deviceRssiNotifier[deviceKey]?.value ?? -100;
//   }

//   Timer? _rssiUpdateTimer;

//   void startPeriodicRssiUpdate() {
//     _rssiUpdateTimer?.cancel();
//     _rssiUpdateTimer = Timer.periodic(const Duration(seconds: 2), (_) {
//       for (final deviceKey in connectedDevices.keys) {
//         if (connectedDevices[deviceKey] == true) {
//           _updateRssiForDevice(deviceKey);
//         }
//       }
//     });
//   }

//   Future<void> _updateRssiForDevice(String deviceKey) async {
//     final deviceId = connectedDeviceIds[deviceKey];
//     if (deviceId == null || deviceId.isEmpty) return;

//     // Create a temporary subscription to get the RSSI for the device.
//     final completer = Completer<int>();
//     final sub = _ble
//         .scanForDevices(withServices: [], scanMode: ScanMode.lowLatency)
//         .listen(
//           (device) {
//             if (device.id == deviceId) {
//               // Update your reactive notifier here.
//               deviceRssiNotifier[deviceKey]?.value = device.rssi;
//               completer.complete(device.rssi);
//               debugPrint("üì° RSSI updated for $deviceKey: ${device.rssi}");
//             }
//           },
//           onError: (e, st) {
//             debugPrint("Error updating RSSI: $e");
//             Sentry.captureException(e, stackTrace: st);
//             completer.completeError(e);
//           },
//         );

//     try {
//       await completer.future.timeout(const Duration(seconds: 3));
//     } catch (e) {
//       debugPrint("RSSI update timed out for $deviceKey: $e");
//     } finally {
//       await sub.cancel();
//     }
//   }

//   void stopPeriodicRssiUpdate() {
//     _rssiUpdateTimer?.cancel();
//     _rssiUpdateTimer = null;
//   }

//   @override
//   void dispose() {
//     _disposed = true;
//     _rssiUpdateTimer?.cancel();
//     _connectionSubscriptions.forEach((_, sub) => sub.cancel());
//     _notificationSubscriptions.forEach((_, sub) => sub.cancel());
//     _connectionSubscriptions.clear();
//     _notificationSubscriptions.clear();
//     _messageStreamController.close();
//     _disconnectionStreamController.close();
//     super.dispose();
//   }
// }





























// // // -------------------------------------------------------------------------------------------------------

// // // CODE 0 flutter_reactive_ble
// // // //ignore_for_file: deprecated_member_use, discoverServices
// // // import 'dart:async';
// // // import 'dart:collection';
// // // import 'dart:convert';
// // // import 'dart:io' show Platform;
// // // import 'package:flutter/foundation.dart' show kIsWeb;
// // // import 'package:flutter/material.dart';
// // // import 'package:flutter_reactive_ble/flutter_reactive_ble.dart';
// // // import 'package:sentry_flutter/sentry_flutter.dart';
// // // import 'package:box_sensors/state/timer_state.dart';
// // // import 'package:box_sensors/services/database_helper.dart';

// // // class BluetoothManager with ChangeNotifier {
// // //   // Reactive BLE instance.
// // //   final FlutterReactiveBle _ble = FlutterReactiveBle();

// // //   TimerState? _timerState;
// // //   int? _currentRoundId;
// // //   int? _currentMatchId;
// // //   final bool _disposed = false;
// // //   bool _manualDisconnect = false;

// // //   // Streams for table rows and disconnection events.
// // //   final StreamController<List<DataRow>> _messageStreamController =
// // //       StreamController<List<DataRow>>.broadcast();
// // //   final StreamController<String?> _disconnectionStreamController =
// // //       StreamController<String?>.broadcast();

// // //   // Connected devices map.
// // //   final Map<String, bool> connectedDevices = {
// // //     'BlueBoxer': false,
// // //     'RedBoxer': false,
// // //     'BoxerServer': false,
// // //   };
// // //   final Map<String, String> connectedDeviceIds = {
// // //     'BlueBoxer': '',
// // //     'RedBoxer': '',
// // //     'BoxerServer': '',
// // //   };

// // //   // ‚úÖ NEW: Reactive ValueNotifier for connection status.
// // //   final ValueNotifier<Map<String, bool>> connectedDevicesNotifier =
// // //       ValueNotifier<Map<String, bool>>({
// // //     'BlueBoxer': false,
// // //     'RedBoxer': false,
// // //     'BoxerServer': false,
// // //   });

// // //   // Connection & notification subscriptions.
// // //   final Map<String, StreamSubscription<ConnectionStateUpdate>> _connectionSubscriptions = {};
// // //   final Map<String, StreamSubscription<List<int>>> _notificationSubscriptions = {};

// // //   // Optional writable characteristic.
// // //   QualifiedCharacteristic? writableCharacteristic;

// // //   // Data table rows and database.
// // //   List<DataRow> rows = [];
// // //   final DatabaseHelper dbHelper = DatabaseHelper();

// // //   // Getters.
// // //   Stream<List<DataRow>> get messageStream => _messageStreamController.stream;
// // //   Stream<String?> get disconnectionStream => _disconnectionStreamController.stream;
// // //   int? get currentRoundId => _currentRoundId;
// // //   int? get currentMatchId => _currentMatchId;
// // //   bool get isConnectedDevice1 => connectedDevices['BlueBoxer'] ?? false;
// // //   bool get isConnectedDevice2 => connectedDevices['RedBoxer'] ?? false;
// // //   bool get isConnectedDevice3 => connectedDevices['BoxerServer'] ?? false;

// // //   /// Returns a device key using the discovered device‚Äôs name or its id.
// // //   String getDeviceKey(DiscoveredDevice device) {
// // //     final name = device.name.trim();
// // //     return name.isEmpty || name.toLowerCase() == 'unknown'
// // //         ? device.id
// // //         : name;
// // //   }

// // //   /// Inject TimerState.
// // //   void setTimerState(TimerState timerState) {
// // //     debugPrint('setTimerState(...) called with timerState=$timerState');
// // //     _timerState = timerState;
// // //   }

// // //   void setCurrentRoundId(int roundId) {
// // //     _currentRoundId = roundId;
// // //     _safeNotifyListeners();
// // //   }

// // //   void setCurrentMatchId(int? matchId) {
// // //     _currentMatchId = matchId;
// // //     _safeNotifyListeners();
// // //   }

// // //   /// Clear the in-memory table.
// // //   void clearTable() {
// // //     if (rows.isEmpty) {
// // //       debugPrint("Table is already clear.");
// // //       return;
// // //     }
// // //     rows.clear();
// // //     if (!_messageStreamController.isClosed) {
// // //       _messageStreamController.add([]);
// // //     }
// // //     _safeNotifyListeners();
// // //   }

// // //   /// Discover services and subscribe to notifiable characteristics.
// // //   Future<void> discoverServices(String deviceKey, String deviceId) async {
// // //     debugPrint("üîç Discovering services for device: $deviceKey");
// // //     try {
// // //       final List<DiscoveredService> services = await _ble.discoverServices(deviceId);
// // //       for (final service in services) {
// // //         for (final characteristic in service.characteristics) {
// // //           if (characteristic.isNotifiable || characteristic.isIndicatable) {
// // //             final subKey = '$deviceKey-${characteristic.characteristicId}';
// // //             if (_notificationSubscriptions.containsKey(subKey)) {
// // //               debugPrint("‚ö†Ô∏è Already subscribed to $subKey, skipping.");
// // //               continue;
// // //             }
// // //             debugPrint("‚úÖ Subscribing to characteristic ${characteristic.characteristicId} for $deviceKey.");
// // //             final qualified = QualifiedCharacteristic(
// // //               deviceId: deviceId,
// // //               serviceId: service.serviceId,
// // //               characteristicId: characteristic.characteristicId,
// // //             );
// // //             final subscription = _ble.subscribeToCharacteristic(qualified).listen(
// // //               (data) => _handleNotification(data, deviceKey),
// // //               onError: (error, stackTrace) {
// // //                 debugPrint("‚ùå Error in notification stream for $deviceKey: $error");
// // //                 Sentry.captureException(error, stackTrace: stackTrace);
// // //               },
// // //             );
// // //             _notificationSubscriptions[subKey] = subscription;
// // //           }
// // //         }
// // //       }
// // //     } catch (e, stackTrace) {
// // //       debugPrint("‚ùå Error discovering services for $deviceKey: $e");
// // //       Sentry.captureException(e, stackTrace: stackTrace);
// // //     }
// // //   }

// // //   /// Process incoming notifications.
// // //   ///
// // //   /// This method first tries to decode JSON; if that fails, it falls back to regex extraction.
// // //   /// After extraction, it checks if the timestamp or sensor value (or punchCount) are missing.
// // //   /// If any of these values are missing (i.e. using default values), it skips adding the row.
// // //   void _handleNotification(List<int> value, String deviceKey) async {
// // //     if (_disposed) return;
// // //     try {
// // //       final decodedMessage = utf8.decode(value);
// // //       debugPrint("üì© Received notification from $deviceKey: $decodedMessage");

// // //       String? punchCount;
// // //       String? timestamp;
// // //       String? sensorValue;

// // //       // Try JSON decode.
// // //       dynamic parsed;
// // //       try {
// // //         parsed = json.decode(decodedMessage);
// // //       } catch (_) {
// // //         // Not JSON.
// // //       }
// // //       if (parsed is Map<String, dynamic>) {
// // //         if (parsed.containsKey("PunchCount")) {
// // //           punchCount = parsed["PunchCount"].toString();
// // //         }
// // //         if (parsed.containsKey("Timestamp")) {
// // //           timestamp = parsed["Timestamp"].toString();
// // //         }
// // //         if (parsed.containsKey("Sensor")) {
// // //           sensorValue = parsed["Sensor"].toString();
// // //         } else if (parsed.containsKey("Sensor millivolts")) {
// // //           sensorValue = parsed["Sensor millivolts"].toString();
// // //         }
// // //         if (parsed["RoundState"] == "Completed") {
// // //           _timerState?.endMatch();      // End the match. very important to check other things here.
// // //         }
// // //       }

// // //       // Fallback to regex extraction if JSON did not provide values.
// // //       punchCount ??= _extractPunchCount(decodedMessage);
// // //       timestamp ??= _extractTimestamp(decodedMessage);
// // //       sensorValue ??= _extractSensorValue(decodedMessage);

// // //       // Use default values if still missing.
// // //       punchCount = punchCount ?? "N/A";
// // //       timestamp = timestamp ?? "";
// // //       sensorValue = sensorValue ?? "";

// // //       // ***** NEW: If any of the key fields are missing, skip this notification.
// // //       if (punchCount == "N/A" || timestamp.isEmpty || sensorValue.isEmpty) {
// // //         debugPrint("Skipping notification due to missing sensor data: PunchCount=$punchCount, Timestamp='$timestamp', Sensor='$sensorValue'");
// // //         return;
// // //       }

// // //       // Determine device name.
// // //       String deviceFromMessage = _extractDevice(decodedMessage);
// // //       if (deviceFromMessage == "UnknownDevice") {
// // //         deviceFromMessage = deviceKey;
// // //       }

// // //       // Create a new row.
// // //       final newRow = DataRow(
// // //         cells: [
// // //           DataCell(Center(child: Text(deviceFromMessage))),
// // //           DataCell(Center(child: Text(deviceFromMessage == "BlueBoxer" ? "RedBoxer" : "BlueBoxer"))),
// // //           DataCell(Center(child: Text(punchCount))),
// // //           DataCell(Center(child: Text(timestamp))),
// // //           DataCell(Center(child: Text(sensorValue))),
// // //         ],
// // //       );
// // //       rows.add(newRow);
// // //       _messageStreamController.add(List.from(rows));
// // //       _safeNotifyListeners();

// // //       // Insert data into the database.
// // //       final localRoundId = _currentRoundId;
// // //       final localMatchId = _currentMatchId;
// // //       if (localMatchId == null) {
// // //         _sendDataAndInsertToDatabase(
// // //           deviceFromMessage,
// // //           (deviceFromMessage == "BlueBoxer") ? "RedBoxer" : "BlueBoxer",
// // //           punchCount,
// // //           timestamp,
// // //           sensorValue,
// // //           0,
// // //           null,
// // //         );
// // //       } else {
// // //         _sendDataAndInsertToDatabase(
// // //           deviceFromMessage,
// // //           (deviceFromMessage == "BlueBoxer") ? "RedBoxer" : "BlueBoxer",
// // //           punchCount,
// // //           timestamp,
// // //           sensorValue,
// // //           localRoundId ?? 0,
// // //           localMatchId,
// // //         );
// // //       }
// // //     } catch (e, stackTrace) {
// // //       if (!_disposed) {
// // //         debugPrint("‚ùå Error processing notification from $deviceKey: $e");
// // //         Sentry.captureException(e, stackTrace: stackTrace);
// // //       }
// // //     }
// // //   }

// // //   // --- REGEX patterns for fallback extraction ---
// // //   static final RegExp _deviceRegex       = RegExp(r'Device:\s*(\S+)');
// // //   static final RegExp _punchCountRegex   = RegExp(r'Punch Count:\s*([\d:]+)');
// // //   static final RegExp _timestampRegex    = RegExp(r'Timestamp:\s*([\d:]+)');
// // //   static final RegExp _sensorValueRegex  = RegExp(r'Sensor millivolts:\s*(\d+)');

// // //   String _extractDevice(String message) =>
// // //       _extractValue(message, _deviceRegex) ?? "UnknownDevice";
// // //   String? _extractPunchCount(String message) =>
// // //       _extractValue(message, _punchCountRegex);
// // //   String? _extractTimestamp(String message) =>
// // //       _extractValue(message, _timestampRegex);
// // //   String? _extractSensorValue(String message) =>
// // //       _extractValue(message, _sensorValueRegex);

// // //   String? _extractValue(String message, RegExp regex) {
// // //     final match = regex.firstMatch(message);
// // //     return match?.group(1);
// // //   }

// // //   /// Send a text message to all connected devices.
// // //   Future<void> sendMessageToAllConnectedDevices(String message) async {
// // //     final trimmedMessage = message.trim();
// // //     if (trimmedMessage.isEmpty || trimmedMessage == "[]") {
// // //       debugPrint("Refusing to send empty/bracket message.");
// // //       return;
// // //     }
// // //     final futures = <Future<void>>[];
// // //     for (final deviceKey in connectedDevices.keys) {
// // //       final deviceId = connectedDeviceIds[deviceKey] ?? '';
// // //       if (deviceId.isNotEmpty) {
// // //         futures.add(
// // //           _sendMessageToDevice(deviceKey, deviceId, trimmedMessage)
// // //               .catchError((e, stackTrace) {
// // //             debugPrint("Error sending message to $deviceKey: $e");
// // //             Sentry.captureException(e, stackTrace: stackTrace);
// // //           }),
// // //         );
// // //       }
// // //     }
// // //     if (futures.isEmpty) {
// // //       debugPrint("No connected devices to send the message.");
// // //       return;
// // //     }
// // //     await Future.wait(futures);
// // //   }

// // //   /// Helper to discover a writable characteristic and send a message.
// // //   Future<void> _sendMessageToDevice(String deviceKey, String deviceId, String message) async {
// // //     try {
// // //       final services = await _ble.discoverServices(deviceId);
// // //       final List<Future<void>> writeFutures = [];
// // //       for (final service in services) {
// // //         for (final characteristic in service.characteristics) {
// // //           if (characteristic.isWritableWithResponse || characteristic.isWritableWithoutResponse) {
// // //             debugPrint("Found writable characteristic ${characteristic.characteristicId} on $deviceKey");
// // //             final qualified = QualifiedCharacteristic(
// // //               deviceId: deviceId,
// // //               serviceId: service.serviceId,
// // //               characteristicId: characteristic.characteristicId,
// // //             );
// // //             writeFutures.add(
// // //               _ble.writeCharacteristicWithResponse(
// // //                 qualified,
// // //                 value: utf8.encode(message),
// // //               ).then((_) {
// // //                 debugPrint("Message sent to $deviceKey via ${characteristic.characteristicId}: $message");
// // //               }).catchError((error, stackTrace) {
// // //                 debugPrint("Error sending message via ${characteristic.characteristicId} on $deviceKey: $error");
// // //                 Sentry.captureException(error, stackTrace: stackTrace);
// // //               }),
// // //             );
// // //           }
// // //         }
// // //       }
// // //       if (writeFutures.isEmpty) {
// // //         debugPrint("No writable characteristics found on $deviceKey.");
// // //       } else {
// // //         await Future.wait(writeFutures);
// // //       }
// // //     } catch (e, stackTrace) {
// // //       debugPrint("Error in _sendMessageToDevice for $deviceKey: $e");
// // //       Sentry.captureException(e, stackTrace: stackTrace);
// // //     }
// // //   }

// // //   /// A simpler single-device send.
// // //   Future<void> sendMessageToConnectedDevice(String message) async {
// // //     final trimmedMessage = message.trim();
// // //     if (trimmedMessage.isEmpty || trimmedMessage == "[]") {
// // //       debugPrint("Refusing to send empty/bracket message.");
// // //       return;
// // //     }
// // //     if (writableCharacteristic != null) {
// // //       try {
// // //         await _ble.writeCharacteristicWithResponse(
// // //           writableCharacteristic!,
// // //           value: utf8.encode(trimmedMessage),
// // //         );
// // //         debugPrint("Message sent via cached characteristic: $trimmedMessage");
// // //         return;
// // //       } catch (e, stackTrace) {
// // //         debugPrint("Error sending message via cached characteristic: $e");
// // //         Sentry.captureException(e, stackTrace: stackTrace);
// // //         debugPrint("Falling back to service discovery.");
// // //       }
// // //     }
// // //     final fallbackEntry = connectedDeviceIds.entries.firstWhere(
// // //       (entry) => entry.value.isNotEmpty,
// // //       orElse: () => const MapEntry("", ""),
// // //     );
// // //     if (fallbackEntry.key.isEmpty) {
// // //       debugPrint("No connected devices available for fallback.");
// // //       return;
// // //     }
// // //     await _sendMessageToDevice(fallbackEntry.key, fallbackEntry.value, trimmedMessage);
// // //   }

// // //   /// Sends JSON-formatted data to BoxerServer.
// // //   Future<void> sendDataToBoxerServer({
// // //     required String deviceStr,
// // //     required String oppositeDevice,
// // //     required String punchCount,
// // //     required String timestamp,
// // //     required String sensorValue,
// // //   }) async {
// // //     final dataMap = {
// // //       "deviceStr": deviceStr,
// // //       "oppositeDevice": oppositeDevice,
// // //       "punchCount": punchCount,
// // //       "timestamp": timestamp,
// // //       "sensorValue": sensorValue,
// // //     };
// // //     final dataMessage = jsonEncode(dataMap);
// // //     debugPrint("Sending data to BoxerServer (JSON): $dataMessage");

// // //     final boxerServerId = connectedDeviceIds["BoxerServer"] ?? '';
// // //     if (boxerServerId.isEmpty) {
// // //       debugPrint("BoxerServer is not connected. Cannot send data.");
// // //       return;
// // //     }
// // //     try {
// // //       await _sendMessageToDevice("BoxerServer", boxerServerId, dataMessage);
// // //       debugPrint("Data sent to BoxerServer successfully.");
// // //     } catch (e, stackTrace) {
// // //       debugPrint("Error sending data to BoxerServer: $e");
// // //       Sentry.captureException(e, stackTrace: stackTrace);
// // //     }
// // //   }

// // //   /// Insert into DB and send data concurrently.
// // //   void _sendDataAndInsertToDatabase(
// // //     String deviceStr,
// // //     String oppositeDevice,
// // //     String punchCount,
// // //     String timestamp,
// // //     String sensorValue,
// // //     int roundId,
// // //     int? matchId,
// // //   ) {
// // //     if (matchId != null) {
// // //       Future.wait([
// // //         _sendDataToBoxerServer(deviceStr, oppositeDevice, punchCount, timestamp, sensorValue),
// // //         _insertDataToDatabase(deviceStr, oppositeDevice, punchCount, timestamp, sensorValue, roundId, matchId),
// // //       ]);
// // //     } else {
// // //       Future.wait([
// // //         _sendDataToBoxerServer(deviceStr, oppositeDevice, punchCount, timestamp, sensorValue),
// // //         _insertTrainingDataToDatabase(deviceStr, oppositeDevice, punchCount, timestamp, sensorValue),
// // //       ]);
// // //     }
// // //   }

// // //   Future<void> _insertDataToDatabase(
// // //     String deviceStr,
// // //     String oppositeDevice,
// // //     String punchCount,
// // //     String timestamp,
// // //     String sensorValue,
// // //     int roundId,
// // //     int matchId,
// // //   ) async {
// // //     try {
// // //       await dbHelper.insertMessage(deviceStr, oppositeDevice, punchCount, timestamp, sensorValue, roundId, matchId);
// // //     } catch (e, stackTrace) {
// // //       debugPrint("‚ùå Error inserting message into DB: $e");
// // //       Sentry.captureException(e, stackTrace: stackTrace);
// // //     }
// // //   }

// // //   Future<void> _insertTrainingDataToDatabase(
// // //     String deviceStr,
// // //     String oppositeDevice,
// // //     String punchCount,
// // //     String timestamp,
// // //     String sensorValue,
// // //   ) async {
// // //     try {
// // //       await dbHelper.insertTrainingData(deviceStr, oppositeDevice, punchCount, timestamp, sensorValue);
// // //     } catch (e, stackTrace) {
// // //       debugPrint("‚ùå Error inserting training data into DB: $e");
// // //       Sentry.captureException(e, stackTrace: stackTrace);
// // //     }
// // //   }

// // //   /// Helper to send data to BoxerServer.
// // //   Future<void> _sendDataToBoxerServer(
// // //     String deviceStr,
// // //     String oppositeDevice,
// // //     String punchCount,
// // //     String timestamp,
// // //     String sensorValue,
// // //   ) async {
// // //     if (!isDeviceConnected("BoxerServer")) {
// // //       debugPrint("‚ùå BoxerServer not connected. Skipping data send.");
// // //       return;
// // //     }
// // //     try {
// // //       await sendDataToBoxerServer(
// // //         deviceStr: deviceStr,
// // //         oppositeDevice: oppositeDevice,
// // //         punchCount: punchCount,
// // //         timestamp: timestamp,
// // //         sensorValue: sensorValue,
// // //       );
// // //     } catch (e, stackTrace) {
// // //       debugPrint("‚ùå Error sending data to BoxerServer: $e");
// // //       Sentry.captureException(e, stackTrace: stackTrace);
// // //     }
// // //   }

// // //   /// Connect to a device (with optional MTU request on Android).
// // //   Future<void> connectToDevice(DiscoveredDevice device) async {
// // //     final deviceKey = getDeviceKey(device);
// // //     if (connectedDeviceIds[deviceKey]?.isNotEmpty ?? false) {
// // //       debugPrint("Device $deviceKey is already connected.");
// // //       return;
// // //     }

// // //     _manualDisconnect = false;
// // //     try {
// // //       final connectionStream = _ble.connectToDevice(
// // //         id: device.id,
// // //         connectionTimeout: const Duration(seconds: 5),
// // //       );
// // //       final subscription = connectionStream.listen(
// // //         (update) async {
// // //           debugPrint("Connection update for $deviceKey: ${update.connectionState}");
// // //           if (update.connectionState == DeviceConnectionState.connected) {
// // //             connectedDeviceIds[deviceKey] = device.id;
// // //             _updateDeviceConnectionStatus(deviceKey, true);
// // //             _safeNotifyListeners();

// // //             // REQUEST A LARGER MTU ON ANDROID
// // //             if (Platform.isAndroid) {
// // //               try {
// // //                 final newMtu = await _ble.requestMtu(
// // //                   deviceId: device.id,
// // //                   mtu: 512, // 247 or 512, depending on hardware/OS
// // //                 );
// // //                 debugPrint("MTU set to $newMtu for $deviceKey");
// // //               } catch (mtuError, st) {
// // //                 debugPrint("Error requesting MTU: $mtuError");
// // //                 Sentry.captureException(mtuError, stackTrace: st);
// // //               }
// // //             }

// // //             await discoverServices(deviceKey, device.id);

// // //           } else if (update.connectionState == DeviceConnectionState.disconnected) {
// // //             _updateDeviceConnectionStatus(deviceKey, false);
// // //             connectedDeviceIds[deviceKey] = '';
// // //             _disconnectionStreamController.add(deviceKey);
// // //             await _connectionSubscriptions[deviceKey]?.cancel();
// // //             _connectionSubscriptions.remove(deviceKey);
// // //             _safeNotifyListeners();

// // //             if (!_manualDisconnect) {
// // //               Future.delayed(const Duration(seconds: 3), () {
// // //                 if (!_disposed) {
// // //                   debugPrint("Attempting to reconnect to $deviceKey...");
// // //                   connectToDevice(device).catchError((e, stackTrace) {
// // //                     debugPrint("Reconnection to $deviceKey failed: $e");
// // //                     Sentry.captureException(e, stackTrace: stackTrace);
// // //                   });
// // //                 }
// // //               });
// // //             }
// // //           }
// // //         },
// // //         onError: (error, stackTrace) {
// // //           debugPrint("‚ùå Error in connection stream for $deviceKey: $error");
// // //           Sentry.captureException(error, stackTrace: stackTrace);
// // //         },
// // //       );
// // //       _connectionSubscriptions[deviceKey] = subscription;
// // //     } catch (e, stackTrace) {
// // //       debugPrint("Error connecting to device $deviceKey: $e");
// // //       _updateDeviceConnectionStatus(deviceKey, false);
// // //       _safeNotifyListeners();
// // //       Sentry.captureException(e, stackTrace: stackTrace);
// // //     }
// // //   }

// // //   /// Disconnect from all devices.
// // //   Future<void> disconnectFromDevice() async {
// // //     _manualDisconnect = true;
// // //     final futures = <Future<void>>[];
// // //     for (final deviceKey in connectedDevices.keys) {
// // //       final deviceId = connectedDeviceIds[deviceKey] ?? '';
// // //       if (deviceId.isNotEmpty) {
// // //         futures.add(_disconnectDevice(deviceKey));
// // //       }
// // //     }
// // //     await Future.wait(futures);
// // //     _safeNotifyListeners();
// // //   }

// // //   Future<void> _disconnectDevice(String deviceKey) async {
// // //     try {
// // //       await _connectionSubscriptions[deviceKey]?.cancel();
// // //       _connectionSubscriptions.remove(deviceKey);
// // //       _notificationSubscriptions.removeWhere((key, _) => key.startsWith(deviceKey));
// // //       connectedDeviceIds[deviceKey] = '';
// // //       _updateDeviceConnectionStatus(deviceKey, false);
// // //       _disconnectionStreamController.add(deviceKey);
// // //     } catch (e, stackTrace) {
// // //       debugPrint("Error disconnecting from device $deviceKey: $e");
// // //       Sentry.captureException(e, stackTrace: stackTrace);
// // //     }
// // //   }

// // //   // ‚úÖ Modified _updateDeviceConnectionStatus to update both connectedDevices and the notifier,
// // //   // then notify listeners so that UI (which reads connectedDevices) is refreshed.
// // //   void _updateDeviceConnectionStatus(String deviceKey, bool status) {
// // //     if (!connectedDevices.containsKey(deviceKey)) {
// // //       debugPrint("Warning: $deviceKey not in connectedDevices map.");
// // //       return;
// // //     }
// // //     if (connectedDevices[deviceKey] != status) {
// // //       connectedDevices[deviceKey] = status;
// // //       connectedDevicesNotifier.value = {
// // //         ...connectedDevicesNotifier.value,
// // //         deviceKey: status,
// // //       };
// // //       debugPrint('$deviceKey connection status updated to: $status');
// // //       _safeNotifyListeners();
// // //     }
// // //   }

// // //   bool isDeviceConnected(String deviceKey) => connectedDevices[deviceKey] ?? false;

// // //   /// Basic scan for devices.
// // //   Future<void> scanForDevices({List<Uuid>? withServices}) async {
// // //     if (kIsWeb || !(Platform.isAndroid || Platform.isIOS)) {
// // //       debugPrint("BLE scanning not supported on this platform.");
// // //       return;
// // //     }
// // //     debugPrint("Starting BLE scan...");
// // //     try {
// // //       _ble.scanForDevices(
// // //         withServices: withServices ?? [],
// // //         scanMode: ScanMode.lowLatency,
// // //       ).listen((device) {
// // //         debugPrint("Found device: ${device.name} (${device.id})");
// // //       }, onError: (error) {
// // //         debugPrint("Error during scan: $error");
// // //         Sentry.captureException(error);
// // //       });
// // //     } catch (e, stackTrace) {
// // //       debugPrint("Scan error: $e");
// // //       Sentry.captureException(e, stackTrace: stackTrace);
// // //     }
// // //   }

// // //   /// Return a read-only view of unique messages (empty for now).
// // //   Set<String> getUniqueMessages() {
// // //     return UnmodifiableSetView({});
// // //   }

// // //   void _safeNotifyListeners() {
// // //     if (!_disposed) {
// // //       notifyListeners();
// // //     }
// // //   }

// // //   // ‚òÖ NEW: Add readRssi method to update connected devices' RSSI via connection-based read.
// // //   Future<int> readRssi(String deviceName) async {
// // //     final deviceId = connectedDeviceIds[deviceName];
// // //     if (deviceId == null || deviceId.isEmpty) {
// // //       throw Exception("Device $deviceName is not connected");
// // //     }
// // //     final completer = Completer<int>();
// // //     final scanSub = _ble.scanForDevices(
// // //       withServices: [],
// // //       scanMode: ScanMode.lowLatency,
// // //     ).listen((DiscoveredDevice device) {
// // //       if (device.id == deviceId) {
// // //         completer.complete(device.rssi);
// // //       }
// // //     }, onError: (error) {
// // //       completer.completeError(error);
// // //     });
// // //     try {
// // //       final rssi = await completer.future.timeout(const Duration(seconds: 3));
// // //       return rssi;
// // //     } catch (e) {
// // //       throw Exception("Failed to read RSSI for $deviceName: $e");
// // //     } finally {
// // //       await scanSub.cancel();
// // //     }
// // //   }

// // //   @override
// // //   void dispose() {
// // //     _messageStreamController.close();
// // //     _disconnectionStreamController.close();
// // //     _notificationSubscriptions.forEach((_, sub) => sub.cancel());
// // //     _notificationSubscriptions.clear();
// // //     _connectionSubscriptions.forEach((_, sub) => sub.cancel());
// // //     _connectionSubscriptions.clear();
// // //     super.dispose();
// // //   }
// // // }

